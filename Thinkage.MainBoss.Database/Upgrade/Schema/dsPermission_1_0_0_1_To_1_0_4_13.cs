



//-----------------------------------------------------------------------------------------------
// <autogenerated>
//		This code was generated by the XAFBuild tool.
//		Template file DBIGenerationTemplate.xml
//		Vault version 131
//		XAFBuild title: Thinkage.XAFBuild.StudioAddin in Thinkage ToolKit 3.0.3.0
//		Changes to this file will be lost if the code is regenerated.
// #defines
//  <TableName>RowChangedEvents to have row changed events enabled
//	DefineForeignKeyConstraints - for the ForeignKeyConstraints to be enabled
//	DefineUniqueConstraints - for the UniqueConstraints to be enabled
//  SerializationSupport - for the Serialization of the dataset Constructor to be enabled
// </autogenerated>
//-----------------------------------------------------------------------------------------------

namespace Thinkage.MainBoss.Database {
	using System.Linq;
	using System;
	using System.Xml;
	using System.Runtime.Serialization;
	using Thinkage.Libraries.XAF.Database.Layout;
	using Thinkage.Libraries.XAF.Database.Service;
	using Thinkage.Libraries.DBAccess;
	using System.Collections.Generic;

	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2240:ImplementISerializableCorrectly"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2229:ImplementSerializationConstructors"), Serializable()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.ComponentModel.ToolboxItem(true)]
	[Thinkage.Libraries.Translation.Invariant]
	public class dsPermission_1_0_0_1_To_1_0_4_13 : DBDataSet {

		#region Database Variables VAccessor
		public VAccessor V {
			get {
				if (_V == null)
					_V = new VAccessor(this);
				return _V;
			}
		}
		private VAccessor _V;
		[Thinkage.Libraries.Translation.Invariant]
		public class VAccessor {
			#region Typed Variable Accessors
			#endregion
			#region VAccessor Construction
			public VAccessor(dsPermission_1_0_0_1_To_1_0_4_13 this_dataset )
			{
			}
			#endregion
		}
		#endregion


		#region Custom DataSet Construction
		internal void CommonCTOR() {
			InitClass();
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			VariablesChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		[Obsolete("Do not call this, it is only here to support DataSet.Clone.", true)]
		public dsPermission_1_0_0_1_To_1_0_4_13() : base() {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsPermission_1_0_0_1_To_1_0_4_13(DBClient db) : base(Schema, db) {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsPermission_1_0_0_1_To_1_0_4_13(IServer server) : base(Schema, server) {
			CommonCTOR();
		}
#if SerializationSupport
		protected dsPermission_1_0_0_1_To_1_0_4_13(SerializationInfo info, StreamingContext context) {
			/// ExtendedProperties are not copied in this CTOR if they are not part of the input stream. In particular, any delgate extended properties
			/// we put on datatables may not be copied. If we end up with any delegate extended properties on datatables, then we will need to
			/// amend the code below to propogate the properties itself
			string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
			if ((strSchema != null)) {
				var ds = new System.Data.DataSet();
				ds.ReadXmlSchema(XmlReader.Create(new System.IO.StringReader(strSchema)));
				TODO: Variables need streaming support
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission) != null)) {
					this.Tables.Add(new PermissionDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User) != null)) {
					this.Tables.Add(new UserDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User)));
				}
				this.DataSetName = ds.DataSetName;
				this.Prefix = ds.Prefix;
				this.Namespace = ds.Namespace;
				this.Locale = ds.Locale;
				this.CaseSensitive = ds.CaseSensitive;
				this.EnforceConstraints = ds.EnforceConstraints;
				this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			}
			else
				this.InitClass();

			this.GetSerializationData(info, context);
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			DataVariables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
#endif
		protected override void InitClass() {
			this.DataSetName = "dsPermission_1_0_0_1_To_1_0_4_13";
			this.Prefix = "";
			this.EnforceConstraints = false;
			base.InitClass();
			#region Foreign Key Constraints
			#if DefineForeignKeyConstraints

			ForeignKeyConstraint fkc;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tableUser.IdColumn}, new DataColumn[] {
						this.tablePermission.F.UserID});
			this.tablePermission.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			#endif
			#endregion

		}
		#endregion

		#region Table Accessor Struct
		public TAccessor T {
			get {
				if (_T == null)
					_T = new TAccessor(this);
				return _T;
			}
		}
		private TAccessor _T;
		public class TAccessor {
			public TAccessor( dsPermission_1_0_0_1_To_1_0_4_13 this_dataset ) {
				this.Permission = (PermissionDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission);
				this.User = (UserDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User);
			}
			public readonly PermissionDataTable Permission;
			public readonly UserDataTable User;
		}
		#endregion
		#region Default-table accessor struct
		public DTAccessor DT {
			get {
				if (_DT == null)
					_DT = new DTAccessor(this);
				return _DT;
			}
		}
		private DTAccessor _DT;
		public class DTAccessor {
			public DTAccessor( dsPermission_1_0_0_1_To_1_0_4_13 this_dataset ) {
				this.Permission = (PermissionDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission.Default);
				this.User = (UserDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User.Default);
			}
			public readonly PermissionDataTable Permission;
			public readonly UserDataTable User;
		}
		#endregion
		#region DataSet Streaming
		#if SerializationSupport
		protected override bool ShouldSerializeTables() {
			return false;
		}
		protected override bool ShouldSerializeRelations() {
			return false;
		}
		protected override void ReadXmlSerializable(XmlReader reader) {
			this.Reset();
			var ds = new System.Data.DataSet();
			ds.ReadXml(reader);
			TODO: Variables need streaming support
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission) != null)) {
				this.Tables.Add(new PermissionDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User) != null)) {
				this.Tables.Add(new UserDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User)));
			}
			this.DataSetName = ds.DataSetName;
			this.Prefix = ds.Prefix;
			this.Namespace = ds.Namespace;
			this.Locale = ds.Locale;
			this.CaseSensitive = ds.CaseSensitive;
			this.EnforceConstraints = ds.EnforceConstraints;
			this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			this.InitVars();
		}
		protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
			System.IO.MemoryStream stream = new System.IO.MemoryStream();
			this.WriteXmlSchema(XmlWriter.Create(stream));
			stream.Position = 0;
			return System.Xml.Schema.XmlSchema.Read(XmlReader.Create(stream), null);
		}
		#endif
		#endregion

		#region Custom-derived DataTable Classes
		#region PermissionDataTable
		private bool ShouldSerializePermission() {
			return false;
		}
#if PermissionRowChangeEvents
		public delegate void PermissionRowChangeEventHandler(object sender, PermissionRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class PermissionDataTable : DBICustomDataTable<PermissionRow> {
			#region Construction
			internal PermissionDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal PermissionDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(PermissionDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.Id);
				  this.UserID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.UserID);
				  this.PermissionPathPattern = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.PermissionPathPattern);
				  this.Grant = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.Grant);
				}
				/// <summary>
				/// Denotes the Permission's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the Permission's UserID column with type link(nonnull, field User.Id) with labelkey='User'
				/// </summary>
				public readonly DBIDataColumn UserID;
				/// <summary>
				/// Denotes the Permission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
				/// </summary>
				public readonly DBIDataColumn PermissionPathPattern;
				/// <summary>
				/// Denotes the Permission's Grant column with type bool(nonnull) with labelkey='Grant'
				/// </summary>
				public readonly DBIDataColumn Grant;
			}
			#endregion
			#region EventHandlers
			#if PermissionRowChangeEvents
			public event PermissionRowChangeEventHandler PermissionRowChanged;
			public event PermissionRowChangeEventHandler PermissionRowChanging;
			public event PermissionRowChangeEventHandler PermissionRowDeleted;
			public event PermissionRowChangeEventHandler PermissionRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.PermissionRowChanged?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.PermissionRowChanging?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.PermissionRowDeleted?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.PermissionRowDeleting?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new PermissionDataTable(Schema, Server);
			public PermissionRow AddNewRow() => (PermissionRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsPermission_1_0_0_1_To_1_0_4_13.Schema.T.Permission);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new PermissionRow(builder);
			public new dsPermission_1_0_0_1_To_1_0_4_13 DataSet => (dsPermission_1_0_0_1_To_1_0_4_13)base.DataSet;
		}
		#region PermissionRow
		[Thinkage.Libraries.Translation.Invariant]
		public class PermissionRow : DBICustomDataRow<PermissionDataTable> {
			#region Construction
			internal PermissionRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly PermissionDataTable this_table;
				private readonly PermissionRow this_row;
				public FAccessor( PermissionRow this_row )
				{
					this.this_table = ((PermissionDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the Permission's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.Permission.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the Permission's UserID column with type link(nonnull, field User.Id) with labelkey='User'
				/// </summary>
				public System.Guid UserID {
					get {
							return (System.Guid)Schema.T.Permission.F.UserID.EffectiveType.GenericAsNativeType(this_table.F.UserID[this_row], typeof(System.Guid));
					}
					set {this_table.F.UserID[this_row] = value; }
				}
				/// <summary>
				/// Denotes the Permission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
				/// </summary>
				public System.String PermissionPathPattern {
					get {
							return (System.String)Schema.T.Permission.F.PermissionPathPattern.EffectiveType.GenericAsNativeType(this_table.F.PermissionPathPattern[this_row], typeof(System.String));
					}
					set {this_table.F.PermissionPathPattern[this_row] = value; }
				}
				/// <summary>
				/// Denotes the Permission's Grant column with type bool(nonnull) with labelkey='Grant'
				/// </summary>
				public System.Boolean Grant {
					get {
							return (System.Boolean)Schema.T.Permission.F.Grant.EffectiveType.GenericAsNativeType(this_table.F.Grant[this_row], typeof(System.Boolean));
					}
					set {this_table.F.Grant[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			public UserRow UserIDParentRow => Table.DataSet.T.User.Rows.Find(F.UserID);
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region PermissionRowChangeEvent
#if PermissionRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class PermissionRowChangeEvent : EventArgs {

			private PermissionRow eventRow;

			private DataRowAction eventAction;

			public PermissionRowChangeEvent(PermissionRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public PermissionRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region UserDataTable
		private bool ShouldSerializeUser() {
			return false;
		}
#if UserRowChangeEvents
		public delegate void UserRowChangeEventHandler(object sender, UserRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class UserDataTable : DBICustomDataTable<UserRow> {
			#region Construction
			internal UserDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal UserDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(UserDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.Id);
				  this.ScopeName = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.ScopeName);
				  this.UserName = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.UserName);
				  this.Hidden = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.Hidden);
				  this.IsGroup = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.IsGroup);
				  this.Desc = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.Desc);
				  this.Comment = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.Comment);
				}
				/// <summary>
				/// Denotes the User's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the User's ScopeName column with type string(minlength 1, maxlength 200, maxlines 0, trim) with labelkey='ScopeName'
				/// </summary>
				public readonly DBIDataColumn ScopeName;
				/// <summary>
				/// Denotes the User's UserName column with type string(nonnull, minlength 1, maxlength 200, maxlines 0, trim) with labelkey='UserName'
				/// </summary>
				public readonly DBIDataColumn UserName;
				/// <summary>
				/// Denotes the User's Hidden column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='Hidden'
				/// </summary>
				public readonly DBIDataColumn Hidden;
				/// <summary>
				/// Denotes the User's IsGroup column with type bool(nonnull) with labelkey='IsGroup'
				/// </summary>
				public readonly DBIDataColumn IsGroup;
				/// <summary>
				/// Denotes the User's Desc column with type string(minlength 1, maxlength 150, maxlines 0, trim) with labelkey='Desc'
				/// </summary>
				public readonly DBIDataColumn Desc;
				/// <summary>
				/// Denotes the User's Comment column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Comment'
				/// </summary>
				public readonly DBIDataColumn Comment;
			}
			#endregion
			#region EventHandlers
			#if UserRowChangeEvents
			public event UserRowChangeEventHandler UserRowChanged;
			public event UserRowChangeEventHandler UserRowChanging;
			public event UserRowChangeEventHandler UserRowDeleted;
			public event UserRowChangeEventHandler UserRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.UserRowChanged?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.UserRowChanging?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.UserRowDeleted?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.UserRowDeleting?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new UserDataTable(Schema, Server);
			public UserRow AddNewRow() => (UserRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsPermission_1_0_0_1_To_1_0_4_13.Schema.T.User);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new UserRow(builder);
			public new dsPermission_1_0_0_1_To_1_0_4_13 DataSet => (dsPermission_1_0_0_1_To_1_0_4_13)base.DataSet;
		}
		#region UserRow
		[Thinkage.Libraries.Translation.Invariant]
		public class UserRow : DBICustomDataRow<UserDataTable> {
			#region Construction
			internal UserRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly UserDataTable this_table;
				private readonly UserRow this_row;
				public FAccessor( UserRow this_row )
				{
					this.this_table = ((UserDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the User's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.User.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the User's ScopeName column with type string(minlength 1, maxlength 200, maxlines 0, trim) with labelkey='ScopeName'
				/// </summary>
				public System.String ScopeName {
					get {
							return (System.String)Schema.T.User.F.ScopeName.EffectiveType.GenericAsNativeType(this_table.F.ScopeName[this_row], typeof(System.String));
					}
					set {this_table.F.ScopeName[this_row] = value; }
				}
				/// <summary>
				/// Denotes the User's UserName column with type string(nonnull, minlength 1, maxlength 200, maxlines 0, trim) with labelkey='UserName'
				/// </summary>
				public System.String UserName {
					get {
							return (System.String)Schema.T.User.F.UserName.EffectiveType.GenericAsNativeType(this_table.F.UserName[this_row], typeof(System.String));
					}
					set {this_table.F.UserName[this_row] = value; }
				}
				/// <summary>
				/// Denotes the User's Hidden column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='Hidden'
				/// </summary>
				public System.DateTime? Hidden {
					get {
							return (System.DateTime?)Schema.T.User.F.Hidden.EffectiveType.GenericAsNativeType(this_table.F.Hidden[this_row], typeof(System.DateTime?));
					}
					set {this_table.F.Hidden[this_row] = value; }
				}
				/// <summary>
				/// Denotes the User's IsGroup column with type bool(nonnull) with labelkey='IsGroup'
				/// </summary>
				public System.Boolean IsGroup {
					get {
							return (System.Boolean)Schema.T.User.F.IsGroup.EffectiveType.GenericAsNativeType(this_table.F.IsGroup[this_row], typeof(System.Boolean));
					}
					set {this_table.F.IsGroup[this_row] = value; }
				}
				/// <summary>
				/// Denotes the User's Desc column with type string(minlength 1, maxlength 150, maxlines 0, trim) with labelkey='Desc'
				/// </summary>
				public System.String Desc {
					get {
							return (System.String)Schema.T.User.F.Desc.EffectiveType.GenericAsNativeType(this_table.F.Desc[this_row], typeof(System.String));
					}
					set {this_table.F.Desc[this_row] = value; }
				}
				/// <summary>
				/// Denotes the User's Comment column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Comment'
				/// </summary>
				public System.String Comment {
					get {
							return (System.String)Schema.T.User.F.Comment.EffectiveType.GenericAsNativeType(this_table.F.Comment[this_row], typeof(System.String));
					}
					set {this_table.F.Comment[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			#endregion
			#region Referring-record accessors
			public IEnumerable<PermissionRow> GetPermissionUserIDChildRows() => Table.DataSet.T.Permission.Rows.Where(r => Schema.T.User.F.Id.EffectiveType.GenericEquals(r.F.UserID, F.Id));
			#endregion
		}
		#endregion
		#region UserRowChangeEvent
#if UserRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class UserRowChangeEvent : EventArgs {

			private UserRow eventRow;

			private DataRowAction eventAction;

			public UserRowChangeEvent(UserRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public UserRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#endregion

		#region Custom database schema definitions
		#region - the custom Schema class
		/// <summary>
		/// Singleton class containing the schema of all tables,
		/// columns, and relationships in a database.
		/// </summary>
		[Thinkage.Libraries.Translation.Invariant]
		public class SchemaClass : DBI_Database {
			#region singleton construction
			private SchemaClass() {
				_T = new TAccessor(this);
				vstruct = new VAccessor(this);
				__Permission = new DBI_Permission();
				Tables.Add( __Permission);
				__User = new DBI_User();
				Tables.Add( __User);
				CompleteDBI(System.Reflection.Assembly.GetExecutingAssembly(), "manifest://localhost/Thinkage/MainBoss/Database/Upgrade/Schema/dsPermission_1_0_0_1_To_1_0_4_13.xafdb", typeof(dsPermission_1_0_0_1_To_1_0_4_13)
				);
			 }
			/// <summary>
			/// The instantiation of the singleton SchemaClass object
			/// </summary>
			public static readonly SchemaClass Instance = new SchemaClass();
			#endregion
			#region Custom DBI_Table derivations and their private reference in the schema object
			#region - Permission table
			private DBI_Permission __Permission;

			/// <summary>
			/// Class to describe a Permission table
			/// </summary>
			public class DBI_Permission : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __UserID;
				private DBI_Column __PermissionPathPattern;
				private DBI_Column __Grant;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_Permission this_table;
					public FAccessor( DBI_Permission this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the Permission's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the Permission's UserID column with type link(nonnull, field User.Id) with labelkey='User'
					/// </summary>
					public DBI_Column UserID { get { return this_table.__UserID; } }
					/// <summary>
					/// Denotes the Permission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
					/// </summary>
					public DBI_Column PermissionPathPattern { get { return this_table.__PermissionPathPattern; } }
					/// <summary>
					/// Denotes the Permission's Grant column with type bool(nonnull) with labelkey='Grant'
					/// </summary>
					public DBI_Column Grant { get { return this_table.__Grant; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_Permission()
					: base("Permission", (DBI_Table tableSchema, IServer s) => new PermissionDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 4, "Table 'Permission' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__UserID = Columns["UserID"];
					System.Diagnostics.Debug.Assert(__UserID != null, "Column 'UserID' not found");
					__PermissionPathPattern = Columns["PermissionPathPattern"];
					System.Diagnostics.Debug.Assert(__PermissionPathPattern != null, "Column 'PermissionPathPattern' not found");
					__Grant = Columns["Grant"];
					System.Diagnostics.Debug.Assert(__Grant != null, "Column 'Grant' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - User table
			private DBI_User __User;

			/// <summary>
			/// Class to describe a User table
			/// </summary>
			public class DBI_User : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __ScopeName;
				private DBI_Column __UserName;
				private DBI_Column __Hidden;
				private DBI_Column __IsGroup;
				private DBI_Column __Desc;
				private DBI_Column __Comment;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_User this_table;
					public FAccessor( DBI_User this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the User's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the User's ScopeName column with type string(minlength 1, maxlength 200, maxlines 0, trim) with labelkey='ScopeName'
					/// </summary>
					public DBI_Column ScopeName { get { return this_table.__ScopeName; } }
					/// <summary>
					/// Denotes the User's UserName column with type string(nonnull, minlength 1, maxlength 200, maxlines 0, trim) with labelkey='UserName'
					/// </summary>
					public DBI_Column UserName { get { return this_table.__UserName; } }
					/// <summary>
					/// Denotes the User's Hidden column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='Hidden'
					/// </summary>
					public DBI_Column Hidden { get { return this_table.__Hidden; } }
					/// <summary>
					/// Denotes the User's IsGroup column with type bool(nonnull) with labelkey='IsGroup'
					/// </summary>
					public DBI_Column IsGroup { get { return this_table.__IsGroup; } }
					/// <summary>
					/// Denotes the User's Desc column with type string(minlength 1, maxlength 150, maxlines 0, trim) with labelkey='Desc'
					/// </summary>
					public DBI_Column Desc { get { return this_table.__Desc; } }
					/// <summary>
					/// Denotes the User's Comment column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Comment'
					/// </summary>
					public DBI_Column Comment { get { return this_table.__Comment; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_User()
					: base("User", (DBI_Table tableSchema, IServer s) => new UserDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 7, "Table 'User' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__ScopeName = Columns["ScopeName"];
					System.Diagnostics.Debug.Assert(__ScopeName != null, "Column 'ScopeName' not found");
					__UserName = Columns["UserName"];
					System.Diagnostics.Debug.Assert(__UserName != null, "Column 'UserName' not found");
					__Hidden = Columns["Hidden"];
					System.Diagnostics.Debug.Assert(__Hidden != null, "Column 'Hidden' not found");
					__IsGroup = Columns["IsGroup"];
					System.Diagnostics.Debug.Assert(__IsGroup != null, "Column 'IsGroup' not found");
					__Desc = Columns["Desc"];
					System.Diagnostics.Debug.Assert(__Desc != null, "Column 'Desc' not found");
					__Comment = Columns["Comment"];
					System.Diagnostics.Debug.Assert(__Comment != null, "Column 'Comment' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#endregion
			#region T - the public portal for getting the custom-typed DBI_Table objects for each table
			public struct TAccessor {
				private SchemaClass this_schema;
				public TAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Accessors
				/// <summary>
				/// Denotes the Permission table with labelkey='Permission'
				/// </summary>
				public DBI_Permission Permission { get { return this_schema.__Permission; }}
				/// <summary>
				/// Denotes the User table with labelkey='User'
				/// </summary>
				public DBI_User User { get { return this_schema.__User; }}
				#endregion
			}
			public TAccessor T { get { return _T; } }
			private TAccessor _T;
			#endregion
			#region V - the public portal for getting the DBI_Variable objects for Database Variables
			public struct VAccessor {
				private SchemaClass this_schema;
				public VAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Variable Accessors
				#endregion
			}
			public VAccessor V { get { return vstruct; } }	// Variables
			private VAccessor vstruct;
			#endregion
		}
		#endregion
		#region - The static member that contains the Schema
		public readonly static SchemaClass Schema = SchemaClass.Instance;
		// make a member variable in the class for reference in a dynamic type instance of this object
		public readonly SchemaClass SchemaDynamic = Schema;
		#endregion
		#endregion
		#region Database Path definitions
		[Thinkage.Libraries.Translation.Invariant]
		public class PathClass {
			/// <summary>
			/// Class containing the relationship paths of all tables,
			/// </summary>
			public readonly TAccessor T;
			/// <summary>
			/// Private constructor for singleton creation
			/// </summary>
			private PathClass() {
				T = new TAccessor(this);
			}

			/// <summary>
			/// The instantiation of the singleton Path object
			/// </summary>
			public static readonly PathClass Instance = new PathClass();
			#region DBI_Path Definitions

			#region DBI_Path Permission
			private PathToPermissionRow __pPermission = new PathToPermissionRow( SchemaClass.Instance.T.Permission );

			/// <summary>
			/// The Permission path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToPermissionRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToUserLink _UserID;
				private PathToField _PermissionPathPattern;
				private PathToField _Grant;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToPermissionRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToPermissionRow _BasePath;
					/// <summary>
					/// Provides the path to Permission's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.Permission.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to Permission's UserID with type link(nonnull, field User.Id) and labelkey='User'
					/// </summary>
					public PathToUserLink UserID { get { if (_BasePath._UserID == null) _BasePath._UserID = new PathToUserLink(_BasePath, Schema.T.Permission.F.UserID ); return _BasePath._UserID; } }
					/// <summary>
					/// Provides the path to Permission's PermissionPathPattern with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) and labelkey='PermissionPathPattern'
					/// </summary>
					public PathToField PermissionPathPattern { get { if (_BasePath._PermissionPathPattern == null) _BasePath._PermissionPathPattern = new PathToField(_BasePath, Schema.T.Permission.F.PermissionPathPattern ); return _BasePath._PermissionPathPattern; } }
					/// <summary>
					/// Provides the path to Permission's Grant with type bool(nonnull) and labelkey='Grant'
					/// </summary>
					public PathToField Grant { get { if (_BasePath._Grant == null) _BasePath._Grant = new PathToField(_BasePath, Schema.T.Permission.F.Grant ); return _BasePath._Grant; } }
				}

				internal PathToPermissionRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToPermissionRow( DBI_Table t ) : base( t ) { }
				internal PathToPermissionRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToPermissionLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToPermissionRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToPermissionRow PathToReferencedRow { get { return (PathToPermissionRow)base.PathToReferencedRow; } }

				internal PathToPermissionLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToPermissionRow(rootTableSchema, columns);
				}
			}
			public class LinkToPermission {
				public LinkToPermission(DBI_Path referencing_path) {
					Id = new PathToPermissionRow(referencing_path.PathThroughLinkage(Schema.T.Permission.F.Id));
				}
				public readonly PathToPermissionRow Id;
			}
			#endregion

			#region DBI_Path User
			private PathToUserRow __pUser = new PathToUserRow( SchemaClass.Instance.T.User );

			/// <summary>
			/// The User path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToField _ScopeName;
				private PathToField _UserName;
				private PathToField _Hidden;
				private PathToField _IsGroup;
				private PathToField _Desc;
				private PathToField _Comment;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToUserRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToUserRow _BasePath;
					/// <summary>
					/// Provides the path to User's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.User.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to User's ScopeName with type string(minlength 1, maxlength 200, maxlines 0, trim) and labelkey='ScopeName'
					/// </summary>
					public PathToField ScopeName { get { if (_BasePath._ScopeName == null) _BasePath._ScopeName = new PathToField(_BasePath, Schema.T.User.F.ScopeName ); return _BasePath._ScopeName; } }
					/// <summary>
					/// Provides the path to User's UserName with type string(nonnull, minlength 1, maxlength 200, maxlines 0, trim) and labelkey='UserName'
					/// </summary>
					public PathToField UserName { get { if (_BasePath._UserName == null) _BasePath._UserName = new PathToField(_BasePath, Schema.T.User.F.UserName ); return _BasePath._UserName; } }
					/// <summary>
					/// Provides the path to User's Hidden with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) and labelkey='Hidden'
					/// </summary>
					public PathToField Hidden { get { if (_BasePath._Hidden == null) _BasePath._Hidden = new PathToField(_BasePath, Schema.T.User.F.Hidden ); return _BasePath._Hidden; } }
					/// <summary>
					/// Provides the path to User's IsGroup with type bool(nonnull) and labelkey='IsGroup'
					/// </summary>
					public PathToField IsGroup { get { if (_BasePath._IsGroup == null) _BasePath._IsGroup = new PathToField(_BasePath, Schema.T.User.F.IsGroup ); return _BasePath._IsGroup; } }
					/// <summary>
					/// Provides the path to User's Desc with type string(minlength 1, maxlength 150, maxlines 0, trim) and labelkey='Desc'
					/// </summary>
					public PathToField Desc { get { if (_BasePath._Desc == null) _BasePath._Desc = new PathToField(_BasePath, Schema.T.User.F.Desc ); return _BasePath._Desc; } }
					/// <summary>
					/// Provides the path to User's Comment with type string(minlength 1, (maxlength 1,073,741,823), trim) and labelkey='Comment'
					/// </summary>
					public PathToField Comment { get { if (_BasePath._Comment == null) _BasePath._Comment = new PathToField(_BasePath, Schema.T.User.F.Comment ); return _BasePath._Comment; } }
				}

				internal PathToUserRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToUserRow( DBI_Table t ) : base( t ) { }
				internal PathToUserRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToUserRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToUserRow PathToReferencedRow { get { return (PathToUserRow)base.PathToReferencedRow; } }

				internal PathToUserLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToUserRow(rootTableSchema, columns);
				}
			}
			public class LinkToUser {
				public LinkToUser(DBI_Path referencing_path) {
					Id = new PathToUserRow(referencing_path.PathThroughLinkage(Schema.T.User.F.Id));
				}
				public readonly PathToUserRow Id;
			}
			#endregion
			public class PathToField : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				[System.Obsolete("This field is not a linkage field", true)]
				public new PathToField PathToReferencedRow { get { return null; } }

				internal PathToField( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
			}
			#endregion
			public struct TAccessor {
				private PathClass this_path;
				public TAccessor( PathClass this_path )
				{
					this.this_path = this_path;
				}
				#region Accessors
				/// <summary>
				/// Provides the root path for Permission with labelkey='Permission'
				/// </summary>
				public PathToPermissionRow Permission { get { return this_path.__pPermission; } }
				/// <summary>
				/// Provides the root path for User with labelkey='User'
				/// </summary>
				public PathToUserRow User { get { return this_path.__pUser; } }
				#endregion
			}
			public class LAccessorBase {
				protected LAccessorBase(DBI_Path basePath) {
					BasePath = basePath;
				}
				protected readonly DBI_Path BasePath;
				#region Cached Accessor results
				protected PathClass.LinkToPermission _Permission;
				protected PathClass.LinkToUser _User;
				#endregion
			}
			public class LAccessor : LAccessorBase {
				public LAccessor( DBI_Path this_path ) 
					: base(this_path) {
				}
				#region Accessors
				public PathClass.LinkToPermission Permission { get { if (base._Permission == null) base._Permission = new PathClass.LinkToPermission(base.BasePath); return base._Permission; } }
				public PathClass.LinkToUser User { get { if (base._User == null) base._User = new PathClass.LinkToUser(base.BasePath); return base._User; } }
				#endregion
			}
		}
		public static readonly PathClass Path = PathClass.Instance;
		#endregion
		#region Label Key Building
		public class LabelKeyBuilder : Thinkage.Libraries.Translation.GeneralKeyBuilder {
			static LabelKeyBuilder Instance = new LabelKeyBuilder();
			private LabelKeyBuilder() {
			}
			protected override Thinkage.Libraries.Translation.ContextReference GetContext() {
				return Thinkage.Libraries.Translation.ContextReference.New("");
			}
			public static Thinkage.Libraries.Translation.Key K([Thinkage.Libraries.Translation.Context("")]string s) {
				return Instance.BuildKey(s);
			}
		}
		#endregion
	}
}
