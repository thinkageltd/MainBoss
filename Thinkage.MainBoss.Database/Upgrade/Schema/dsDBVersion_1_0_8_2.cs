



//-----------------------------------------------------------------------------------------------
// <autogenerated>
//		This code was generated by the XAFBuild tool.
//		Template file DBIGenerationTemplate.xml
//		Vault version 131
//		XAFBuild title: Thinkage.XAFBuild.StudioAddin in Thinkage ToolKit 3.0.3.0
//		Changes to this file will be lost if the code is regenerated.
// #defines
//  <TableName>RowChangedEvents to have row changed events enabled
//	DefineForeignKeyConstraints - for the ForeignKeyConstraints to be enabled
//	DefineUniqueConstraints - for the UniqueConstraints to be enabled
//  SerializationSupport - for the Serialization of the dataset Constructor to be enabled
// </autogenerated>
//-----------------------------------------------------------------------------------------------

namespace Thinkage.MainBoss.Database {
	using System.Linq;
	using System;
	using System.Xml;
	using System.Runtime.Serialization;
	using Thinkage.Libraries.XAF.Database.Layout;
	using Thinkage.Libraries.XAF.Database.Service;
	using Thinkage.Libraries.DBAccess;
	using System.Collections.Generic;

	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2240:ImplementISerializableCorrectly"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2229:ImplementSerializationConstructors"), Serializable()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.ComponentModel.ToolboxItem(true)]
	[Thinkage.Libraries.Translation.Invariant]
	public class dsDBVersion_1_0_8_2 : DBDataSet {

		#region Database Variables VAccessor
		public VAccessor V {
			get {
				if (_V == null)
					_V = new VAccessor(this);
				return _V;
			}
		}
		private VAccessor _V;
		[Thinkage.Libraries.Translation.Invariant]
		public class VAccessor {
			#region Typed Variable Accessors
			public readonly DBIVariable DBVersion;
			public readonly DBIVariable DBServerVersion;
			#endregion
			#region VAccessor Construction
			public VAccessor(dsDBVersion_1_0_8_2 this_dataset )
			{
				this.DBVersion = this_dataset[Schema.V.DBVersion];
				this.DBServerVersion = this_dataset[Schema.V.DBServerVersion];
			}
			#endregion
		}
		#endregion


		#region Custom DataSet Construction
		internal void CommonCTOR() {
			InitClass();
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			VariablesChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		[Obsolete("Do not call this, it is only here to support DataSet.Clone.", true)]
		public dsDBVersion_1_0_8_2() : base() {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsDBVersion_1_0_8_2(DBClient db) : base(Schema, db) {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsDBVersion_1_0_8_2(IServer server) : base(Schema, server) {
			CommonCTOR();
		}
#if SerializationSupport
		protected dsDBVersion_1_0_8_2(SerializationInfo info, StreamingContext context) {
			/// ExtendedProperties are not copied in this CTOR if they are not part of the input stream. In particular, any delgate extended properties
			/// we put on datatables may not be copied. If we end up with any delegate extended properties on datatables, then we will need to
			/// amend the code below to propogate the properties itself
			string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
			if ((strSchema != null)) {
				var ds = new System.Data.DataSet();
				ds.ReadXmlSchema(XmlReader.Create(new System.IO.StringReader(strSchema)));
				TODO: Variables need streaming support
				this.DataSetName = ds.DataSetName;
				this.Prefix = ds.Prefix;
				this.Namespace = ds.Namespace;
				this.Locale = ds.Locale;
				this.CaseSensitive = ds.CaseSensitive;
				this.EnforceConstraints = ds.EnforceConstraints;
				this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			}
			else
				this.InitClass();

			this.GetSerializationData(info, context);
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			DataVariables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
#endif
		protected override void InitClass() {
			this.DataSetName = "dsDBVersion_1_0_8_2";
			this.Prefix = "";
			this.EnforceConstraints = false;
			base.InitClass();
			#region Foreign Key Constraints
			#if DefineForeignKeyConstraints

			#endif
			#endregion

		}
		#endregion

		#region Table Accessor Struct
		public TAccessor T {
			get {
				if (_T == null)
					_T = new TAccessor(this);
				return _T;
			}
		}
		private TAccessor _T;
		public class TAccessor {
			public TAccessor( dsDBVersion_1_0_8_2 this_dataset ) {
			}
		}
		#endregion
		#region Default-table accessor struct
		public DTAccessor DT {
			get {
				if (_DT == null)
					_DT = new DTAccessor(this);
				return _DT;
			}
		}
		private DTAccessor _DT;
		public class DTAccessor {
			public DTAccessor( dsDBVersion_1_0_8_2 this_dataset ) {
			}
		}
		#endregion
		#region DataSet Streaming
		#if SerializationSupport
		protected override bool ShouldSerializeTables() {
			return false;
		}
		protected override bool ShouldSerializeRelations() {
			return false;
		}
		protected override void ReadXmlSerializable(XmlReader reader) {
			this.Reset();
			var ds = new System.Data.DataSet();
			ds.ReadXml(reader);
			TODO: Variables need streaming support
			this.DataSetName = ds.DataSetName;
			this.Prefix = ds.Prefix;
			this.Namespace = ds.Namespace;
			this.Locale = ds.Locale;
			this.CaseSensitive = ds.CaseSensitive;
			this.EnforceConstraints = ds.EnforceConstraints;
			this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			this.InitVars();
		}
		protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
			System.IO.MemoryStream stream = new System.IO.MemoryStream();
			this.WriteXmlSchema(XmlWriter.Create(stream));
			stream.Position = 0;
			return System.Xml.Schema.XmlSchema.Read(XmlReader.Create(stream), null);
		}
		#endif
		#endregion

		#region Custom-derived DataTable Classes
		#endregion

		#region Custom database schema definitions
		#region - the custom Schema class
		/// <summary>
		/// Singleton class containing the schema of all tables,
		/// columns, and relationships in a database.
		/// </summary>
		[Thinkage.Libraries.Translation.Invariant]
		public class SchemaClass : DBI_Database {
			#region singleton construction
			private SchemaClass() {
				_T = new TAccessor(this);
				vstruct = new VAccessor(this);
				CompleteDBI(System.Reflection.Assembly.GetExecutingAssembly(), "manifest://localhost/Thinkage/MainBoss/Database/Upgrade/Schema/dsDBVersion_1_0_8_2.xafdb", typeof(dsDBVersion_1_0_8_2)
				);
				__VDBVersion = Variables["DBVersion"];
				System.Diagnostics.Debug.Assert(__VDBVersion != null, "Variable 'DBVersion' not found");
				__VDBServerVersion = Variables["DBServerVersion"];
				System.Diagnostics.Debug.Assert(__VDBServerVersion != null, "Variable 'DBServerVersion' not found");
			 }
			/// <summary>
			/// The instantiation of the singleton SchemaClass object
			/// </summary>
			public static readonly SchemaClass Instance = new SchemaClass();
			#endregion
			#region Custom DBI_Table derivations and their private reference in the schema object
			#endregion
			#region T - the public portal for getting the custom-typed DBI_Table objects for each table
			public struct TAccessor {
				private SchemaClass this_schema;
				public TAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Accessors
				#endregion
			}
			public TAccessor T { get { return _T; } }
			private TAccessor _T;
			#endregion
			#region V - the public portal for getting the DBI_Variable objects for Database Variables
			private DBI_Variable __VDBVersion;
			private DBI_Variable __VDBServerVersion;
			public struct VAccessor {
				private SchemaClass this_schema;
				public VAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Variable Accessors
				/// <summary>
				/// Denotes the Database DBVersion variable
				/// </summary>
				public DBI_Variable DBVersion { get { return this_schema.__VDBVersion; } }
				/// <summary>
				/// Denotes the Database DBServerVersion variable
				/// </summary>
				public DBI_Variable DBServerVersion { get { return this_schema.__VDBServerVersion; } }
				#endregion
			}
			public VAccessor V { get { return vstruct; } }	// Variables
			private VAccessor vstruct;
			#endregion
		}
		#endregion
		#region - The static member that contains the Schema
		public readonly static SchemaClass Schema = SchemaClass.Instance;
		// make a member variable in the class for reference in a dynamic type instance of this object
		public readonly SchemaClass SchemaDynamic = Schema;
		#endregion
		#endregion
		#region Database Path definitions
		[Thinkage.Libraries.Translation.Invariant]
		public class PathClass {
			/// <summary>
			/// Class containing the relationship paths of all tables,
			/// </summary>
			public readonly TAccessor T;
			/// <summary>
			/// Private constructor for singleton creation
			/// </summary>
			private PathClass() {
				T = new TAccessor(this);
			}

			/// <summary>
			/// The instantiation of the singleton Path object
			/// </summary>
			public static readonly PathClass Instance = new PathClass();
			#region DBI_Path Definitions
			public class PathToField : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				[System.Obsolete("This field is not a linkage field", true)]
				public new PathToField PathToReferencedRow { get { return null; } }

				internal PathToField( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
			}
			#endregion
			public struct TAccessor {
				private PathClass this_path;
				public TAccessor( PathClass this_path )
				{
					this.this_path = this_path;
				}
				#region Accessors
				#endregion
			}
			public class LAccessorBase {
				protected LAccessorBase(DBI_Path basePath) {
					BasePath = basePath;
				}
				protected readonly DBI_Path BasePath;
				#region Cached Accessor results
				#endregion
			}
			public class LAccessor : LAccessorBase {
				public LAccessor( DBI_Path this_path ) 
					: base(this_path) {
				}
				#region Accessors
				#endregion
			}
		}
		public static readonly PathClass Path = PathClass.Instance;
		#endregion
		#region Label Key Building
		public class LabelKeyBuilder : Thinkage.Libraries.Translation.GeneralKeyBuilder {
			static LabelKeyBuilder Instance = new LabelKeyBuilder();
			private LabelKeyBuilder() {
			}
			protected override Thinkage.Libraries.Translation.ContextReference GetContext() {
				return Thinkage.Libraries.Translation.ContextReference.New("");
			}
			public static Thinkage.Libraries.Translation.Key K([Thinkage.Libraries.Translation.Context("")]string s) {
				return Instance.BuildKey(s);
			}
		}
		#endregion
	}
}
