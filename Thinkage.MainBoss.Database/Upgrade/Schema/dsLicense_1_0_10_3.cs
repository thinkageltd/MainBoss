



//-----------------------------------------------------------------------------------------------
// <autogenerated>
//		This code was generated by the XAFBuild tool.
//		Template file DBIGenerationTemplate.xml
//		Vault version 119
//		XAFBuild title: Thinkage.XAFBuild.StudioAddin in Thinkage ToolKit 3.0.3.0
//		Changes to this file will be lost if the code is regenerated.
// #defines
//  <TableName>RowChangedEvents to have row changed events enabled
//	DefineForeignKeyConstraints - for the ForeignKeyConstraints to be enabled
//	DefineUniqueConstraints - for the UniqueConstraints to be enabled
//  SerializationSupport - for the Serialization of the dataset Constructor to be enabled
// </autogenerated>
//-----------------------------------------------------------------------------------------------

namespace Thinkage.MainBoss.Database {
	using System.Linq;
	using System;
	using System.Data;
	using System.Xml;
	using System.Runtime.Serialization;
	using Thinkage.Libraries.XAF.Database.Layout;
	using Thinkage.Libraries.XAF.Database.Service;
	using Thinkage.Libraries.DBAccess;
	using System.Collections.Generic;

	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2240:ImplementISerializableCorrectly"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2229:ImplementSerializationConstructors"), Serializable()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.ComponentModel.ToolboxItem(true)]
	[Thinkage.Libraries.Translation.Invariant]
	public class dsLicense_1_0_10_3 : DBDataSet {

		#region Database Variables VAccessor
		public VAccessor V {
			get {
				if (_V == null)
					_V = new VAccessor(this);
				return _V;
			}
		}
		private VAccessor _V;
		[Thinkage.Libraries.Translation.Invariant]
		public class VAccessor {
			#region Typed Variable Accessors
			#endregion
			#region VAccessor Construction
			public VAccessor(dsLicense_1_0_10_3 this_dataset )
			{
			}
			#endregion
		}
		#endregion


		#region DataSet Construction

		internal void CommonCTOR() {
			InitClass();
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			VariablesChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		[Obsolete("Do not call this, it is only here to support DataSet.Clone.", true)]
		public dsLicense_1_0_10_3() : base() {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsLicense_1_0_10_3(DBClient db) : base(Schema, db) {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsLicense_1_0_10_3(IServer server) : base(Schema, server) {
			CommonCTOR();
		}
#if SerializationSupport
		protected dsLicense_1_0_10_3(SerializationInfo info, StreamingContext context) {
			/// ExtendedProperties are not copied in this CTOR if they are not part of the input stream. In particular, any delgate extended properties
			/// we put on datatables may not be copied. If we end up with any delegate extended properties on datatables, then we will need to
			/// amend the code below to propogate the properties itself
			string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
			if ((strSchema != null)) {
				DataSet ds = new DataSet();
				ds.ReadXmlSchema(XmlReader.Create(new System.IO.StringReader(strSchema)));
				if (ds.Tables["__Variables"] != null)
					this.Tables.Add( new DataVariable.__VariablesDataTable(ds.Tables["__Variables"]));
				if ((ds.Tables["License"] != null)) {
					this.Tables.Add(new LicenseDataTable(ds.Tables["License"]));
				}
				this.DataSetName = ds.DataSetName;
				this.Prefix = ds.Prefix;
				this.Namespace = ds.Namespace;
				this.Locale = ds.Locale;
				this.CaseSensitive = ds.CaseSensitive;
				this.EnforceConstraints = ds.EnforceConstraints;
				this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			}
			else
				this.InitClass();

			this.GetSerializationData(info, context);
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			DataVariables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
#endif
		protected override void InitClass() {
			this.DataSetName = "dsLicense_1_0_10_3";
			this.Prefix = "";
			this.EnforceConstraints = false;
			base.InitClass();
			#region Foreign Key Constraints
			#if DefineForeignKeyConstraints

			#endif
			#endregion

		}
		#endregion

		#region Table Accessor Struct
		public TAccessor T {
			get {
				if (_T == null)
					_T = new TAccessor(this);
				return _T;
			}
		}
		private TAccessor _T;
		public class TAccessor {
			public TAccessor( dsLicense_1_0_10_3 this_dataset ) {
				this.License = (LicenseDataTable)this_dataset.Tables["License"];
			}
			public readonly LicenseDataTable License;
		}
		#endregion
		#region Default-table accessor struct
		public DTAccessor DT {
			get {
				if (_DT == null)
					_DT = new DTAccessor(this);
				return _DT;
			}
		}
		private DTAccessor _DT;
		public class DTAccessor {
			public DTAccessor( dsLicense_1_0_10_3 this_dataset ) {
				this.License = (LicenseDataTable)this_dataset.Tables["_DLicense"];
			}
			public readonly LicenseDataTable License;
		}
		#endregion
		#region DataSet Streaming
		#if SerializationSupport
		protected override bool ShouldSerializeTables() {
			return false;
		}
		protected override bool ShouldSerializeRelations() {
			return false;
		}
		protected override void ReadXmlSerializable(XmlReader reader) {
			this.Reset();
			DataSet ds = new DataSet();
			ds.ReadXml(reader);
			if ((ds.Tables["__Variables"] != null))
				this.Tables.Add( new DataVariable.__VariablesDataTable(ds.Tables["__Variables"]));
			if ((ds.Tables["License"] != null)) {
				this.Tables.Add(new LicenseDataTable(ds.Tables["License"]));
			}
			this.DataSetName = ds.DataSetName;
			this.Prefix = ds.Prefix;
			this.Namespace = ds.Namespace;
			this.Locale = ds.Locale;
			this.CaseSensitive = ds.CaseSensitive;
			this.EnforceConstraints = ds.EnforceConstraints;
			this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			this.InitVars();
		}
		protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
			System.IO.MemoryStream stream = new System.IO.MemoryStream();
			this.WriteXmlSchema(XmlWriter.Create(stream));
			stream.Position = 0;
			return System.Xml.Schema.XmlSchema.Read(XmlReader.Create(stream), null);
		}
		#endif
		#endregion

		#region DataTable Classes
		#region License
		private bool ShouldSerializeLicense() {
			return false;
		}
#if LicenseRowChangeEvents
		public delegate void LicenseRowChangeEventHandler(object sender, LicenseRowChangeEvent e);
#endif


		[Thinkage.Libraries.Translation.Invariant]
		public class LicenseDataTable : DBIDataTable {
			#region Construction
			internal LicenseDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal LicenseDataTable(DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(LicenseDataTable t) {
				  this.Id = (DBIDataColumn)t.Columns["Id"];
				  this.License = (DBIDataColumn)t.Columns["License"];
				  this.ApplicationID = (DBIDataColumn)t.Columns["ApplicationID"];
				  this.ApplicationName = (DBIDataColumn)t.Columns["ApplicationName"];
				  this.Expiry = (DBIDataColumn)t.Columns["Expiry"];
				  this.ExpiryModel = (DBIDataColumn)t.Columns["ExpiryModel"];
				  this.ExpiryModelName = (DBIDataColumn)t.Columns["ExpiryModelName"];
				  this.LicenseCount = (DBIDataColumn)t.Columns["LicenseCount"];
				  this.LicenseModel = (DBIDataColumn)t.Columns["LicenseModel"];
				  this.LicenseModelName = (DBIDataColumn)t.Columns["LicenseModelName"];
				  this.LicenseID = (DBIDataColumn)t.Columns["LicenseID"];
				}
				/// <summary>
				/// Denotes the License's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the License's License column with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) with labelkey='License'
				/// </summary>
				public readonly DBIDataColumn License;
				/// <summary>
				/// Denotes the License's ApplicationID column with type integer(nonnull, 32) with labelkey='Application'
				/// </summary>
				public readonly DBIDataColumn ApplicationID;
				/// <summary>
				/// Denotes the License's ApplicationName column with type string(nonnull, minlength 1, maxlength 150, maxlines 0, trim) with labelkey='ApplicationName'
				/// </summary>
				public readonly DBIDataColumn ApplicationName;
				/// <summary>
				/// Denotes the License's Expiry column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) with labelkey='Expiry'
				/// </summary>
				public readonly DBIDataColumn Expiry;
				/// <summary>
				/// Denotes the License's ExpiryModel column with type integer(nonnull, 16) with labelkey='ExpiryModel'
				/// </summary>
				public readonly DBIDataColumn ExpiryModel;
				/// <summary>
				/// Denotes the License's ExpiryModelName column with type translationkey(nonnull, maxlines 0, maxkeylength 512) with labelkey='ExpiryModelName'
				/// </summary>
				public readonly DBIDataColumn ExpiryModelName;
				/// <summary>
				/// Denotes the License's LicenseCount column with type integer(nonnull, 64) with labelkey='LicenseCount'
				/// </summary>
				public readonly DBIDataColumn LicenseCount;
				/// <summary>
				/// Denotes the License's LicenseModel column with type integer(nonnull, 16) with labelkey='LicenseModel'
				/// </summary>
				public readonly DBIDataColumn LicenseModel;
				/// <summary>
				/// Denotes the License's LicenseModelName column with type translationkey(nonnull, maxlines 0, maxkeylength 512) with labelkey='LicenseModelName'
				/// </summary>
				public readonly DBIDataColumn LicenseModelName;
				/// <summary>
				/// Denotes the License's LicenseID column with type integer(nonnull, 64) with labelkey='License Id'
				/// </summary>
				public readonly DBIDataColumn LicenseID;
			}
			#endregion
			#region EventHandlers
			#if LicenseRowChangeEvents
			public event LicenseRowChangeEventHandler LicenseRowChanged;
			public event LicenseRowChangeEventHandler LicenseRowChanging;
			public event LicenseRowChangeEventHandler LicenseRowDeleted;
			public event LicenseRowChangeEventHandler LicenseRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.LicenseRowChanged?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.LicenseRowChanging?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.LicenseRowDeleted?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.LicenseRowDeleting?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			#region Instantiation used by DataSet.Clone
			// DataSet.Clone calls.CreateInstance on each table in the DataSet being cloned to make the tables for the new DataSet
			protected override DataTable CreateInstance() {
				return new LicenseDataTable(Schema, Server);
			}
			#endregion
			#region Row Accessors
			[System.ComponentModel.Browsable(false)]
			public int Count {
				get {
					return this.Rows.Count;
				}
			}
			public LicenseRow this[int index] {
				get {
					return ((LicenseRow)(this.Rows[index]));
				}
			}
			public void AddLicenseRow(LicenseRow row) {
				this.Rows.Add(row);
			}
			public LicenseRow AddNewLicenseRow() {
				return ((LicenseRow)(((DBDataSet)this.DataSet).DB.AddNewRowAndBases((DBDataSet)this.DataSet, dsLicense_1_0_10_3.Schema.T.License)));
			}
			protected override DataRow NewRowFromBuilder(DataRowBuilder builder) {
				return new LicenseRow(builder);
			}
			protected override System.Type GetRowType() {
				return typeof(LicenseRow);
			}
			public void RemoveLicenseRow(LicenseRow row) {
				this.Rows.Remove(row);
			}
			#endregion
		}
		#region LicenseRow
		[Thinkage.Libraries.Translation.Invariant]
		public class LicenseRow : DBIDataRow {
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal LicenseRow(DataRowBuilder rb)
				: base(rb) {
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly LicenseDataTable this_table;
				private readonly LicenseRow this_row;
				public FAccessor( LicenseRow this_row )
				{
					this.this_table = ((LicenseDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the License's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.License.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the License's License column with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) with labelkey='License'
				/// </summary>
				public System.String License {
					get {
							return (System.String)Schema.T.License.F.License.EffectiveType.GenericAsNativeType(this_table.F.License[this_row], typeof(System.String));
					}
					set {this_table.F.License[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's ApplicationID column with type integer(nonnull, 32) with labelkey='Application'
				/// </summary>
				public System.Int32 ApplicationID {
					get {
							return (System.Int32)Schema.T.License.F.ApplicationID.EffectiveType.GenericAsNativeType(this_table.F.ApplicationID[this_row], typeof(System.Int32));
					}
					set {this_table.F.ApplicationID[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's ApplicationName column with type string(nonnull, minlength 1, maxlength 150, maxlines 0, trim) with labelkey='ApplicationName'
				/// </summary>
				public System.String ApplicationName {
					get {
							return (System.String)Schema.T.License.F.ApplicationName.EffectiveType.GenericAsNativeType(this_table.F.ApplicationName[this_row], typeof(System.String));
					}
					set {this_table.F.ApplicationName[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's Expiry column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) with labelkey='Expiry'
				/// </summary>
				public System.DateTime? Expiry {
					get {
							return (System.DateTime?)Schema.T.License.F.Expiry.EffectiveType.GenericAsNativeType(this_table.F.Expiry[this_row], typeof(System.DateTime?));
					}
					set {this_table.F.Expiry[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's ExpiryModel column with type integer(nonnull, 16) with labelkey='ExpiryModel'
				/// </summary>
				public System.Int16 ExpiryModel {
					get {
							return (System.Int16)Schema.T.License.F.ExpiryModel.EffectiveType.GenericAsNativeType(this_table.F.ExpiryModel[this_row], typeof(System.Int16));
					}
					set {this_table.F.ExpiryModel[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's ExpiryModelName column with type translationkey(nonnull, maxlines 0, maxkeylength 512) with labelkey='ExpiryModelName'
				/// </summary>
				public Thinkage.Libraries.Translation.SimpleKey ExpiryModelName {
					get {
							return (Thinkage.Libraries.Translation.SimpleKey)Schema.T.License.F.ExpiryModelName.EffectiveType.GenericAsNativeType(this_table.F.ExpiryModelName[this_row], typeof(Thinkage.Libraries.Translation.SimpleKey));
					}
					set {this_table.F.ExpiryModelName[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseCount column with type integer(nonnull, 64) with labelkey='LicenseCount'
				/// </summary>
				public System.Int64 LicenseCount {
					get {
							return (System.Int64)Schema.T.License.F.LicenseCount.EffectiveType.GenericAsNativeType(this_table.F.LicenseCount[this_row], typeof(System.Int64));
					}
					set {this_table.F.LicenseCount[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseModel column with type integer(nonnull, 16) with labelkey='LicenseModel'
				/// </summary>
				public System.Int16 LicenseModel {
					get {
							return (System.Int16)Schema.T.License.F.LicenseModel.EffectiveType.GenericAsNativeType(this_table.F.LicenseModel[this_row], typeof(System.Int16));
					}
					set {this_table.F.LicenseModel[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseModelName column with type translationkey(nonnull, maxlines 0, maxkeylength 512) with labelkey='LicenseModelName'
				/// </summary>
				public Thinkage.Libraries.Translation.SimpleKey LicenseModelName {
					get {
							return (Thinkage.Libraries.Translation.SimpleKey)Schema.T.License.F.LicenseModelName.EffectiveType.GenericAsNativeType(this_table.F.LicenseModelName[this_row], typeof(Thinkage.Libraries.Translation.SimpleKey));
					}
					set {this_table.F.LicenseModelName[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseID column with type integer(nonnull, 64) with labelkey='License Id'
				/// </summary>
				public System.Int64 LicenseID {
					get {
							return (System.Int64)Schema.T.License.F.LicenseID.EffectiveType.GenericAsNativeType(this_table.F.LicenseID[this_row], typeof(System.Int64));
					}
					set {this_table.F.LicenseID[this_row] = value; }
				}
			}
		}
		#endregion
		#region LicenseRowChangeEvent
#if LicenseRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class LicenseRowChangeEvent : EventArgs {

			private LicenseRow eventRow;

			private DataRowAction eventAction;

			public LicenseRowChangeEvent(LicenseRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public LicenseRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#endregion

		#region Custom database schema definitions
		#region - the custom Schema class
		/// <summary>
		/// Singleton class containing the schema of all tables,
		/// columns, and relationships in a database.
		/// </summary>
		[Thinkage.Libraries.Translation.Invariant]
		public class SchemaClass : DBI_Database {
			#region singleton construction
			private SchemaClass() {
				_T = new TAccessor(this);
				vstruct = new VAccessor(this);
				__License = new DBI_License();
				Tables.Add( __License);
				CompleteDBI(System.Reflection.Assembly.GetExecutingAssembly(), "manifest://localhost/Thinkage/MainBoss/Database/Upgrade/Schema/dsLicense_1_0_10_3.xafdb", typeof(dsLicense_1_0_10_3)
				);
			 }
			/// <summary>
			/// The instantiation of the singleton SchemaClass object
			/// </summary>
			public static readonly SchemaClass Instance = new SchemaClass();
			#endregion
			#region Custom DBI_Table derivations and their private reference in the schema object
			#region - License table
			private DBI_License __License;

			/// <summary>
			/// Class to describe a License table
			/// </summary>
			public class DBI_License : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __License;
				private DBI_Column __ApplicationID;
				private DBI_Column __ApplicationName;
				private DBI_Column __Expiry;
				private DBI_Column __ExpiryModel;
				private DBI_Column __ExpiryModelName;
				private DBI_Column __LicenseCount;
				private DBI_Column __LicenseModel;
				private DBI_Column __LicenseModelName;
				private DBI_Column __LicenseID;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_License this_table;
					public FAccessor( DBI_License this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the License's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the License's License column with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) with labelkey='License'
					/// </summary>
					public DBI_Column License { get { return this_table.__License; } }
					/// <summary>
					/// Denotes the License's ApplicationID column with type integer(nonnull, 32) with labelkey='Application'
					/// </summary>
					public DBI_Column ApplicationID { get { return this_table.__ApplicationID; } }
					/// <summary>
					/// Denotes the License's ApplicationName column with type string(nonnull, minlength 1, maxlength 150, maxlines 0, trim) with labelkey='ApplicationName'
					/// </summary>
					public DBI_Column ApplicationName { get { return this_table.__ApplicationName; } }
					/// <summary>
					/// Denotes the License's Expiry column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) with labelkey='Expiry'
					/// </summary>
					public DBI_Column Expiry { get { return this_table.__Expiry; } }
					/// <summary>
					/// Denotes the License's ExpiryModel column with type integer(nonnull, 16) with labelkey='ExpiryModel'
					/// </summary>
					public DBI_Column ExpiryModel { get { return this_table.__ExpiryModel; } }
					/// <summary>
					/// Denotes the License's ExpiryModelName column with type translationkey(nonnull, maxlines 0, maxkeylength 512) with labelkey='ExpiryModelName'
					/// </summary>
					public DBI_Column ExpiryModelName { get { return this_table.__ExpiryModelName; } }
					/// <summary>
					/// Denotes the License's LicenseCount column with type integer(nonnull, 64) with labelkey='LicenseCount'
					/// </summary>
					public DBI_Column LicenseCount { get { return this_table.__LicenseCount; } }
					/// <summary>
					/// Denotes the License's LicenseModel column with type integer(nonnull, 16) with labelkey='LicenseModel'
					/// </summary>
					public DBI_Column LicenseModel { get { return this_table.__LicenseModel; } }
					/// <summary>
					/// Denotes the License's LicenseModelName column with type translationkey(nonnull, maxlines 0, maxkeylength 512) with labelkey='LicenseModelName'
					/// </summary>
					public DBI_Column LicenseModelName { get { return this_table.__LicenseModelName; } }
					/// <summary>
					/// Denotes the License's LicenseID column with type integer(nonnull, 64) with labelkey='License Id'
					/// </summary>
					public DBI_Column LicenseID { get { return this_table.__LicenseID; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_License()
					: base("License", (DBI_Table tableSchema, IServer s) => new LicenseDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 11, "Table 'License' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__License = Columns["License"];
					System.Diagnostics.Debug.Assert(__License != null, "Column 'License' not found");
					__ApplicationID = Columns["ApplicationID"];
					System.Diagnostics.Debug.Assert(__ApplicationID != null, "Column 'ApplicationID' not found");
					__ApplicationName = Columns["ApplicationName"];
					System.Diagnostics.Debug.Assert(__ApplicationName != null, "Column 'ApplicationName' not found");
					__Expiry = Columns["Expiry"];
					System.Diagnostics.Debug.Assert(__Expiry != null, "Column 'Expiry' not found");
					__ExpiryModel = Columns["ExpiryModel"];
					System.Diagnostics.Debug.Assert(__ExpiryModel != null, "Column 'ExpiryModel' not found");
					__ExpiryModelName = Columns["ExpiryModelName"];
					System.Diagnostics.Debug.Assert(__ExpiryModelName != null, "Column 'ExpiryModelName' not found");
					__LicenseCount = Columns["LicenseCount"];
					System.Diagnostics.Debug.Assert(__LicenseCount != null, "Column 'LicenseCount' not found");
					__LicenseModel = Columns["LicenseModel"];
					System.Diagnostics.Debug.Assert(__LicenseModel != null, "Column 'LicenseModel' not found");
					__LicenseModelName = Columns["LicenseModelName"];
					System.Diagnostics.Debug.Assert(__LicenseModelName != null, "Column 'LicenseModelName' not found");
					__LicenseID = Columns["LicenseID"];
					System.Diagnostics.Debug.Assert(__LicenseID != null, "Column 'LicenseID' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#endregion
			#region T - the public portal for getting the custom-typed DBI_Table objects for each table
			public struct TAccessor {
				private SchemaClass this_schema;
				public TAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Accessors
				/// <summary>
				/// Denotes the License table with labelkey='License'
				/// </summary>
				public DBI_License License { get { return this_schema.__License; }}
				#endregion
			}
			public TAccessor T { get { return _T; } }
			private TAccessor _T;
			#endregion
			#region V - the public portal for getting the DBI_Variable objects for Database Variables
			public struct VAccessor {
				private SchemaClass this_schema;
				public VAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Variable Accessors
				#endregion
			}
			public VAccessor V { get { return vstruct; } }	// Variables
			private VAccessor vstruct;
			#endregion
		}
		#endregion
		#region - The static member that contains the Schema
		public readonly static SchemaClass Schema = SchemaClass.Instance;
		// make a member variable in the class for reference in a dynamic type instance of this object
		public readonly SchemaClass SchemaDynamic = Schema;
		#endregion
		#endregion
		#region Database Path definitions
		[Thinkage.Libraries.Translation.Invariant]
		public class PathClass {
			/// <summary>
			/// Class containing the relationship paths of all tables,
			/// </summary>
			public readonly TAccessor T;
			/// <summary>
			/// Private constructor for singleton creation
			/// </summary>
			private PathClass() {
				T = new TAccessor(this);
			}

			/// <summary>
			/// The instantiation of the singleton Path object
			/// </summary>
			public static readonly PathClass Instance = new PathClass();
			#region DBI_Path Definitions

			#region DBI_Path License
			private PathToLicenseRow __pLicense = new PathToLicenseRow( SchemaClass.Instance.T.License );

			/// <summary>
			/// The License path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToLicenseRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToField _License;
				private PathToField _ApplicationID;
				private PathToField _ApplicationName;
				private PathToField _Expiry;
				private PathToField _ExpiryModel;
				private PathToField _ExpiryModelName;
				private PathToField _LicenseCount;
				private PathToField _LicenseModel;
				private PathToField _LicenseModelName;
				private PathToField _LicenseID;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToLicenseRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToLicenseRow _BasePath;
					/// <summary>
					/// Provides the path to License's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.License.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to License's License with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) and labelkey='License'
					/// </summary>
					public PathToField License { get { if (_BasePath._License == null) _BasePath._License = new PathToField(_BasePath, Schema.T.License.F.License ); return _BasePath._License; } }
					/// <summary>
					/// Provides the path to License's ApplicationID with type integer(nonnull, 32) and labelkey='Application'
					/// </summary>
					public PathToField ApplicationID { get { if (_BasePath._ApplicationID == null) _BasePath._ApplicationID = new PathToField(_BasePath, Schema.T.License.F.ApplicationID ); return _BasePath._ApplicationID; } }
					/// <summary>
					/// Provides the path to License's ApplicationName with type string(nonnull, minlength 1, maxlength 150, maxlines 0, trim) and labelkey='ApplicationName'
					/// </summary>
					public PathToField ApplicationName { get { if (_BasePath._ApplicationName == null) _BasePath._ApplicationName = new PathToField(_BasePath, Schema.T.License.F.ApplicationName ); return _BasePath._ApplicationName; } }
					/// <summary>
					/// Provides the path to License's Expiry with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) and labelkey='Expiry'
					/// </summary>
					public PathToField Expiry { get { if (_BasePath._Expiry == null) _BasePath._Expiry = new PathToField(_BasePath, Schema.T.License.F.Expiry ); return _BasePath._Expiry; } }
					/// <summary>
					/// Provides the path to License's ExpiryModel with type integer(nonnull, 16) and labelkey='ExpiryModel'
					/// </summary>
					public PathToField ExpiryModel { get { if (_BasePath._ExpiryModel == null) _BasePath._ExpiryModel = new PathToField(_BasePath, Schema.T.License.F.ExpiryModel ); return _BasePath._ExpiryModel; } }
					/// <summary>
					/// Provides the path to License's ExpiryModelName with type translationkey(nonnull, maxlines 0, maxkeylength 512) and labelkey='ExpiryModelName'
					/// </summary>
					public PathToField ExpiryModelName { get { if (_BasePath._ExpiryModelName == null) _BasePath._ExpiryModelName = new PathToField(_BasePath, Schema.T.License.F.ExpiryModelName ); return _BasePath._ExpiryModelName; } }
					/// <summary>
					/// Provides the path to License's LicenseCount with type integer(nonnull, 64) and labelkey='LicenseCount'
					/// </summary>
					public PathToField LicenseCount { get { if (_BasePath._LicenseCount == null) _BasePath._LicenseCount = new PathToField(_BasePath, Schema.T.License.F.LicenseCount ); return _BasePath._LicenseCount; } }
					/// <summary>
					/// Provides the path to License's LicenseModel with type integer(nonnull, 16) and labelkey='LicenseModel'
					/// </summary>
					public PathToField LicenseModel { get { if (_BasePath._LicenseModel == null) _BasePath._LicenseModel = new PathToField(_BasePath, Schema.T.License.F.LicenseModel ); return _BasePath._LicenseModel; } }
					/// <summary>
					/// Provides the path to License's LicenseModelName with type translationkey(nonnull, maxlines 0, maxkeylength 512) and labelkey='LicenseModelName'
					/// </summary>
					public PathToField LicenseModelName { get { if (_BasePath._LicenseModelName == null) _BasePath._LicenseModelName = new PathToField(_BasePath, Schema.T.License.F.LicenseModelName ); return _BasePath._LicenseModelName; } }
					/// <summary>
					/// Provides the path to License's LicenseID with type integer(nonnull, 64) and labelkey='License Id'
					/// </summary>
					public PathToField LicenseID { get { if (_BasePath._LicenseID == null) _BasePath._LicenseID = new PathToField(_BasePath, Schema.T.License.F.LicenseID ); return _BasePath._LicenseID; } }
				}

				internal PathToLicenseRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToLicenseRow( DBI_Table t ) : base( t ) { }
				internal PathToLicenseRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToLicenseLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToLicenseRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToLicenseRow PathToReferencedRow { get { return (PathToLicenseRow)base.PathToReferencedRow; } }

				internal PathToLicenseLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToLicenseRow(rootTableSchema, columns);
				}
			}
			public class LinkToLicense {
				public LinkToLicense(DBI_Path referencing_path) {
					Id = new PathToLicenseRow(referencing_path.PathThroughLinkage(Schema.T.License.F.Id));
					License = new PathToLicenseRow(referencing_path.PathThroughLinkage(Schema.T.License.F.License));
				}
				public readonly PathToLicenseRow Id;
				public readonly PathToLicenseRow License;
			}
			#endregion
			public class PathToField : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				[System.Obsolete("This field is not a linkage field", true)]
				public new PathToField PathToReferencedRow { get { return null; } }

				internal PathToField( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
			}
			#endregion
			public struct TAccessor {
				private PathClass this_path;
				public TAccessor( PathClass this_path )
				{
					this.this_path = this_path;
				}
				#region Accessors
				/// <summary>
				/// Provides the root path for License with labelkey='License'
				/// </summary>
				public PathToLicenseRow License { get { return this_path.__pLicense; } }
				#endregion
			}
			public class LAccessorBase {
				protected LAccessorBase(DBI_Path basePath) {
					BasePath = basePath;
				}
				protected readonly DBI_Path BasePath;
				#region Cached Accessor results
				protected PathClass.LinkToLicense _License;
				#endregion
			}
			public class LAccessor : LAccessorBase {
				public LAccessor( DBI_Path this_path ) 
					: base(this_path) {
				}
				#region Accessors
				public PathClass.LinkToLicense License { get { if (base._License == null) base._License = new PathClass.LinkToLicense(base.BasePath); return base._License; } }
				#endregion
			}
		}
		public static readonly PathClass Path = PathClass.Instance;
		#endregion
		#region Label Key Building
		public class LabelKeyBuilder : Thinkage.Libraries.Translation.GeneralKeyBuilder {
			static LabelKeyBuilder Instance = new LabelKeyBuilder();
			private LabelKeyBuilder() {
			}
			protected override Thinkage.Libraries.Translation.ContextReference GetContext() {
				return Thinkage.Libraries.Translation.ContextReference.New("dsMBLabel");
			}
			public static Thinkage.Libraries.Translation.Key K([Thinkage.Libraries.Translation.Context("dsMBLabel")]string s) {
				return Instance.BuildKey(s);
			}
		}
		#endregion
	}
	#region LabelKeys
	#if DEFINELABELKEYS
	internal static class dsLicense_1_0_10_3DefineKeysFordsMBLabel {
		static private Thinkage.Libraries.Translation.Key License = dsLicense_1_0_10_3.LabelKeyBuilder.K("License");
		static private Thinkage.Libraries.Translation.Key License_Id = dsLicense_1_0_10_3.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key License_License = dsLicense_1_0_10_3.LabelKeyBuilder.K("License");
		static private Thinkage.Libraries.Translation.Key License_ApplicationID = dsLicense_1_0_10_3.LabelKeyBuilder.K("Application");
		static private Thinkage.Libraries.Translation.Key License_ApplicationName = dsLicense_1_0_10_3.LabelKeyBuilder.K("ApplicationName");
		static private Thinkage.Libraries.Translation.Key License_Expiry = dsLicense_1_0_10_3.LabelKeyBuilder.K("Expiry");
		static private Thinkage.Libraries.Translation.Key License_ExpiryModel = dsLicense_1_0_10_3.LabelKeyBuilder.K("ExpiryModel");
		static private Thinkage.Libraries.Translation.Key License_ExpiryModelName = dsLicense_1_0_10_3.LabelKeyBuilder.K("ExpiryModelName");
		static private Thinkage.Libraries.Translation.Key License_LicenseCount = dsLicense_1_0_10_3.LabelKeyBuilder.K("LicenseCount");
		static private Thinkage.Libraries.Translation.Key License_LicenseModel = dsLicense_1_0_10_3.LabelKeyBuilder.K("LicenseModel");
		static private Thinkage.Libraries.Translation.Key License_LicenseModelName = dsLicense_1_0_10_3.LabelKeyBuilder.K("LicenseModelName");
		static private Thinkage.Libraries.Translation.Key License_LicenseID = dsLicense_1_0_10_3.LabelKeyBuilder.K("License Id");
	}
	#endif
	#endregion
}
