



//-----------------------------------------------------------------------------------------------
// <autogenerated>
//		This code was generated by the XAFBuild tool.
//		Template file DBIGenerationTemplate.xml
//		Vault version 131
//		XAFBuild title: Thinkage.XAFBuild.StudioAddin in Thinkage ToolKit 3.0.3.0
//		Changes to this file will be lost if the code is regenerated.
// #defines
//  <TableName>RowChangedEvents to have row changed events enabled
//	DefineForeignKeyConstraints - for the ForeignKeyConstraints to be enabled
//	DefineUniqueConstraints - for the UniqueConstraints to be enabled
//  SerializationSupport - for the Serialization of the dataset Constructor to be enabled
// </autogenerated>
//-----------------------------------------------------------------------------------------------

namespace Thinkage.MainBoss.Database {
	using System.Linq;
	using System;
	using System.Xml;
	using System.Runtime.Serialization;
	using Thinkage.Libraries.XAF.Database.Layout;
	using Thinkage.Libraries.XAF.Database.Service;
	using Thinkage.Libraries.DBAccess;
	using System.Collections.Generic;

	[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2240:ImplementISerializableCorrectly"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2229:ImplementSerializationConstructors"), Serializable()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.ComponentModel.ToolboxItem(true)]
	[Thinkage.Libraries.Translation.Invariant]
	public class dsUpgrade_1_1_4_2 : DBDataSet {

		#region Database Variables VAccessor
		public VAccessor V {
			get {
				if (_V == null)
					_V = new VAccessor(this);
				return _V;
			}
		}
		private VAccessor _V;
		[Thinkage.Libraries.Translation.Invariant]
		public class VAccessor {
			#region Typed Variable Accessors
			public readonly DBIVariable DBVersion;
			public readonly DBIVariable DBServerVersion;
			#endregion
			#region VAccessor Construction
			public VAccessor(dsUpgrade_1_1_4_2 this_dataset )
			{
				this.DBVersion = this_dataset[Schema.V.DBVersion];
				this.DBServerVersion = this_dataset[Schema.V.DBServerVersion];
			}
			#endregion
		}
		#endregion


		#region Custom DataSet Construction
		internal void CommonCTOR() {
			InitClass();
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			VariablesChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		[Obsolete("Do not call this, it is only here to support DataSet.Clone.", true)]
		public dsUpgrade_1_1_4_2() : base() {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsUpgrade_1_1_4_2(DBClient db) : base(Schema, db) {
			CommonCTOR();
		}
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
		public dsUpgrade_1_1_4_2(IServer server) : base(Schema, server) {
			CommonCTOR();
		}
#if SerializationSupport
		protected dsUpgrade_1_1_4_2(SerializationInfo info, StreamingContext context) {
			/// ExtendedProperties are not copied in this CTOR if they are not part of the input stream. In particular, any delgate extended properties
			/// we put on datatables may not be copied. If we end up with any delegate extended properties on datatables, then we will need to
			/// amend the code below to propogate the properties itself
			string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
			if ((strSchema != null)) {
				var ds = new System.Data.DataSet();
				ds.ReadXmlSchema(XmlReader.Create(new System.IO.StringReader(strSchema)));
				TODO: Variables need streaming support
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission) != null)) {
					this.Tables.Add(new PermissionDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Principal) != null)) {
					this.Tables.Add(new PrincipalDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Principal)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Role) != null)) {
					this.Tables.Add(new RoleDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Role)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User) != null)) {
					this.Tables.Add(new UserDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserRole) != null)) {
					this.Tables.Add(new UserRoleDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserRole)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserPermission) != null)) {
					this.Tables.Add(new UserPermissionDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserPermission)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.License) != null)) {
					this.Tables.Add(new LicenseDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.License)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory) != null)) {
					this.Tables.Add(new DatabaseHistoryDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory)));
				}
				if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.BackupFileName) != null)) {
					this.Tables.Add(new BackupFileNameDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.BackupFileName)));
				}
				this.DataSetName = ds.DataSetName;
				this.Prefix = ds.Prefix;
				this.Namespace = ds.Namespace;
				this.Locale = ds.Locale;
				this.CaseSensitive = ds.CaseSensitive;
				this.EnforceConstraints = ds.EnforceConstraints;
				this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			}
			else
				this.InitClass();

			this.GetSerializationData(info, context);
			Tables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_T = null;
				_DT = null;
			};
			DataVariables.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
				_V = null;
			};
		}
#endif
		protected override void InitClass() {
			this.DataSetName = "dsUpgrade_1_1_4_2";
			this.Prefix = "";
			this.EnforceConstraints = false;
			base.InitClass();
			#region Foreign Key Constraints
			#if DefineForeignKeyConstraints

			ForeignKeyConstraint fkc;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tablePrincipal.IdColumn}, new DataColumn[] {
						this.tablePermission.F.PrincipalID});
			this.tablePermission.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tableRole.IdColumn}, new DataColumn[] {
						this.tablePrincipal.F.RoleID});
			this.tablePrincipal.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tableUser.IdColumn}, new DataColumn[] {
						this.tablePrincipal.F.UserID});
			this.tablePrincipal.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tablePrincipal.IdColumn}, new DataColumn[] {
						this.tableRole.F.PrincipalID});
			this.tableRole.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.Cascade;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tablePrincipal.IdColumn}, new DataColumn[] {
						this.tableUser.F.PrincipalID});
			this.tableUser.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.Cascade;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tablePrincipal.IdColumn}, new DataColumn[] {
						this.tableUserRole.F.PrincipalID});
			this.tableUserRole.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tableUser.IdColumn}, new DataColumn[] {
						this.tableUserRole.F.UserID});
			this.tableUserRole.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			fkc = new ForeignKeyConstraint("", new DataColumn[] {
						this.tableUser.IdColumn}, new DataColumn[] {
						this.tableUserPermission.F.UserID});
			this.tableUserPermission.Constraints.Add(fkc);
			fkc.AcceptRejectRule = System.Data.AcceptRejectRule.None;
			fkc.DeleteRule = System.Data.Rule.None;
			fkc.UpdateRule = System.Data.Rule.Cascade;
			#endif
			#endregion

		}
		#endregion

		#region Table Accessor Struct
		public TAccessor T {
			get {
				if (_T == null)
					_T = new TAccessor(this);
				return _T;
			}
		}
		private TAccessor _T;
		public class TAccessor {
			public TAccessor( dsUpgrade_1_1_4_2 this_dataset ) {
				this.Permission = (PermissionDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission);
				this.Principal = (PrincipalDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Principal);
				this.Role = (RoleDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Role);
				this.User = (UserDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User);
				this.UserRole = (UserRoleDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserRole);
				this.UserPermission = (UserPermissionDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserPermission);
				this.License = (LicenseDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.License);
				this.DatabaseHistory = (DatabaseHistoryDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory);
				this.BackupFileName = (BackupFileNameDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.BackupFileName);
			}
			public readonly PermissionDataTable Permission;
			public readonly PrincipalDataTable Principal;
			public readonly RoleDataTable Role;
			public readonly UserDataTable User;
			public readonly UserRoleDataTable UserRole;
			public readonly UserPermissionDataTable UserPermission;
			public readonly LicenseDataTable License;
			public readonly DatabaseHistoryDataTable DatabaseHistory;
			public readonly BackupFileNameDataTable BackupFileName;
		}
		#endregion
		#region Default-table accessor struct
		public DTAccessor DT {
			get {
				if (_DT == null)
					_DT = new DTAccessor(this);
				return _DT;
			}
		}
		private DTAccessor _DT;
		public class DTAccessor {
			public DTAccessor( dsUpgrade_1_1_4_2 this_dataset ) {
				this.Permission = (PermissionDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission.Default);
				this.Principal = (PrincipalDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Principal.Default);
				this.Role = (RoleDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Role.Default);
				this.User = (UserDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User.Default);
				this.UserRole = (UserRoleDataTable)this_dataset.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserRole.Default);
			}
			public readonly PermissionDataTable Permission;
			public readonly PrincipalDataTable Principal;
			public readonly RoleDataTable Role;
			public readonly UserDataTable User;
			public readonly UserRoleDataTable UserRole;
		}
		#endregion
		#region DataSet Streaming
		#if SerializationSupport
		protected override bool ShouldSerializeTables() {
			return false;
		}
		protected override bool ShouldSerializeRelations() {
			return false;
		}
		protected override void ReadXmlSerializable(XmlReader reader) {
			this.Reset();
			var ds = new System.Data.DataSet();
			ds.ReadXml(reader);
			TODO: Variables need streaming support
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission) != null)) {
				this.Tables.Add(new PermissionDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Permission)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Principal) != null)) {
				this.Tables.Add(new PrincipalDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Principal)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Role) != null)) {
				this.Tables.Add(new RoleDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.Role)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User) != null)) {
				this.Tables.Add(new UserDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.User)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserRole) != null)) {
				this.Tables.Add(new UserRoleDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserRole)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserPermission) != null)) {
				this.Tables.Add(new UserPermissionDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.UserPermission)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.License) != null)) {
				this.Tables.Add(new LicenseDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.License)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory) != null)) {
				this.Tables.Add(new DatabaseHistoryDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory)));
			}
			if ((ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.BackupFileName) != null)) {
				this.Tables.Add(new BackupFileNameDataTable(ds.Tables.FindTableDuringTableConstruction(SchemaClass.Instance.T.BackupFileName)));
			}
			this.DataSetName = ds.DataSetName;
			this.Prefix = ds.Prefix;
			this.Namespace = ds.Namespace;
			this.Locale = ds.Locale;
			this.CaseSensitive = ds.CaseSensitive;
			this.EnforceConstraints = ds.EnforceConstraints;
			this.Merge(ds, false, System.Data.MissingSchemaAction.Add);
			this.InitVars();
		}
		protected override System.Xml.Schema.XmlSchema GetSchemaSerializable() {
			System.IO.MemoryStream stream = new System.IO.MemoryStream();
			this.WriteXmlSchema(XmlWriter.Create(stream));
			stream.Position = 0;
			return System.Xml.Schema.XmlSchema.Read(XmlReader.Create(stream), null);
		}
		#endif
		#endregion

		#region Custom-derived DataTable Classes
		#region PermissionDataTable
		private bool ShouldSerializePermission() {
			return false;
		}
#if PermissionRowChangeEvents
		public delegate void PermissionRowChangeEventHandler(object sender, PermissionRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class PermissionDataTable : DBICustomDataTable<PermissionRow> {
			#region Construction
			internal PermissionDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal PermissionDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(PermissionDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.Id);
				  this.PrincipalID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.PrincipalID);
				  this.PermissionPathPattern = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Permission.F.PermissionPathPattern);
				}
				/// <summary>
				/// Denotes the Permission's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the Permission's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
				/// </summary>
				public readonly DBIDataColumn PrincipalID;
				/// <summary>
				/// Denotes the Permission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
				/// </summary>
				public readonly DBIDataColumn PermissionPathPattern;
			}
			#endregion
			#region EventHandlers
			#if PermissionRowChangeEvents
			public event PermissionRowChangeEventHandler PermissionRowChanged;
			public event PermissionRowChangeEventHandler PermissionRowChanging;
			public event PermissionRowChangeEventHandler PermissionRowDeleted;
			public event PermissionRowChangeEventHandler PermissionRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.PermissionRowChanged?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.PermissionRowChanging?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.PermissionRowDeleted?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.PermissionRowDeleting?.Invoke(this, new PermissionRowChangeEvent(((PermissionRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new PermissionDataTable(Schema, Server);
			public PermissionRow AddNewRow() => (PermissionRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.Permission);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new PermissionRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region PermissionRow
		[Thinkage.Libraries.Translation.Invariant]
		public class PermissionRow : DBICustomDataRow<PermissionDataTable> {
			#region Construction
			internal PermissionRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly PermissionDataTable this_table;
				private readonly PermissionRow this_row;
				public FAccessor( PermissionRow this_row )
				{
					this.this_table = ((PermissionDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the Permission's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.Permission.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the Permission's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
				/// </summary>
				public System.Guid PrincipalID {
					get {
							return (System.Guid)Schema.T.Permission.F.PrincipalID.EffectiveType.GenericAsNativeType(this_table.F.PrincipalID[this_row], typeof(System.Guid));
					}
					set {this_table.F.PrincipalID[this_row] = value; }
				}
				/// <summary>
				/// Denotes the Permission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
				/// </summary>
				public System.String PermissionPathPattern {
					get {
							return (System.String)Schema.T.Permission.F.PermissionPathPattern.EffectiveType.GenericAsNativeType(this_table.F.PermissionPathPattern[this_row], typeof(System.String));
					}
					set {this_table.F.PermissionPathPattern[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			public PrincipalRow PrincipalIDParentRow => Table.DataSet.T.Principal.Rows.Find(F.PrincipalID);
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region PermissionRowChangeEvent
#if PermissionRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class PermissionRowChangeEvent : EventArgs {

			private PermissionRow eventRow;

			private DataRowAction eventAction;

			public PermissionRowChangeEvent(PermissionRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public PermissionRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region PrincipalDataTable
		private bool ShouldSerializePrincipal() {
			return false;
		}
#if PrincipalRowChangeEvents
		public delegate void PrincipalRowChangeEventHandler(object sender, PrincipalRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class PrincipalDataTable : DBICustomDataTable<PrincipalRow> {
			#region Construction
			internal PrincipalDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal PrincipalDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(PrincipalDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Principal.F.Id);
				  this.RoleID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Principal.F.RoleID);
				  this.UserID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Principal.F.UserID);
				}
				/// <summary>
				/// Denotes the Principal's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the Principal's RoleID column with type link(field Role.Id) with labelkey='Role'
				/// </summary>
				public readonly DBIDataColumn RoleID;
				/// <summary>
				/// Denotes the Principal's UserID column with type link(field User.Id) with labelkey='User'
				/// </summary>
				public readonly DBIDataColumn UserID;
			}
			#endregion
			#region EventHandlers
			#if PrincipalRowChangeEvents
			public event PrincipalRowChangeEventHandler PrincipalRowChanged;
			public event PrincipalRowChangeEventHandler PrincipalRowChanging;
			public event PrincipalRowChangeEventHandler PrincipalRowDeleted;
			public event PrincipalRowChangeEventHandler PrincipalRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.PrincipalRowChanged?.Invoke(this, new PrincipalRowChangeEvent(((PrincipalRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.PrincipalRowChanging?.Invoke(this, new PrincipalRowChangeEvent(((PrincipalRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.PrincipalRowDeleted?.Invoke(this, new PrincipalRowChangeEvent(((PrincipalRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.PrincipalRowDeleting?.Invoke(this, new PrincipalRowChangeEvent(((PrincipalRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new PrincipalDataTable(Schema, Server);
			public PrincipalRow AddNewRow() => (PrincipalRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.Principal);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new PrincipalRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region PrincipalRow
		[Thinkage.Libraries.Translation.Invariant]
		public class PrincipalRow : DBICustomDataRow<PrincipalDataTable> {
			#region Construction
			internal PrincipalRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly PrincipalDataTable this_table;
				private readonly PrincipalRow this_row;
				public FAccessor( PrincipalRow this_row )
				{
					this.this_table = ((PrincipalDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the Principal's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.Principal.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the Principal's RoleID column with type link(field Role.Id) with labelkey='Role'
				/// </summary>
				public System.Guid? RoleID {
					get {
							return (System.Guid?)Schema.T.Principal.F.RoleID.EffectiveType.GenericAsNativeType(this_table.F.RoleID[this_row], typeof(System.Guid?));
					}
				}
				/// <summary>
				/// Denotes the Principal's UserID column with type link(field User.Id) with labelkey='User'
				/// </summary>
				public System.Guid? UserID {
					get {
							return (System.Guid?)Schema.T.Principal.F.UserID.EffectiveType.GenericAsNativeType(this_table.F.UserID[this_row], typeof(System.Guid?));
					}
				}
			}
			#endregion
			#region Referenced-record accessors
			public RoleRow RoleIDParentRow => Table.DataSet.T.Role.Rows.Find(F.RoleID);
			public UserRow UserIDParentRow => Table.DataSet.T.User.Rows.Find(F.UserID);
			#endregion
			#region Referring-record accessors
			public IEnumerable<PermissionRow> GetPermissionPrincipalIDChildRows() => Table.DataSet.T.Permission.Rows.Where(r => Schema.T.Principal.F.Id.EffectiveType.GenericEquals(r.F.PrincipalID, F.Id));
			public IEnumerable<RoleRow> GetRolePrincipalIDChildRows() => Table.DataSet.T.Role.Rows.Where(r => Schema.T.Principal.F.Id.EffectiveType.GenericEquals(r.F.PrincipalID, F.Id));
			public IEnumerable<UserRow> GetUserPrincipalIDChildRows() => Table.DataSet.T.User.Rows.Where(r => Schema.T.Principal.F.Id.EffectiveType.GenericEquals(r.F.PrincipalID, F.Id));
			public IEnumerable<UserRoleRow> GetUserRolePrincipalIDChildRows() => Table.DataSet.T.UserRole.Rows.Where(r => Schema.T.Principal.F.Id.EffectiveType.GenericEquals(r.F.PrincipalID, F.Id));
			#endregion
		}
		#endregion
		#region PrincipalRowChangeEvent
#if PrincipalRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class PrincipalRowChangeEvent : EventArgs {

			private PrincipalRow eventRow;

			private DataRowAction eventAction;

			public PrincipalRowChangeEvent(PrincipalRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public PrincipalRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region RoleDataTable
		private bool ShouldSerializeRole() {
			return false;
		}
#if RoleRowChangeEvents
		public delegate void RoleRowChangeEventHandler(object sender, RoleRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class RoleDataTable : DBICustomDataTable<RoleRow> {
			#region Construction
			internal RoleDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal RoleDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(RoleDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Role.F.Id);
				  this.PrincipalID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.Role.F.PrincipalID);
				}
				/// <summary>
				/// Denotes the Role's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the Role's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
				/// </summary>
				public readonly DBIDataColumn PrincipalID;
			}
			#endregion
			#region EventHandlers
			#if RoleRowChangeEvents
			public event RoleRowChangeEventHandler RoleRowChanged;
			public event RoleRowChangeEventHandler RoleRowChanging;
			public event RoleRowChangeEventHandler RoleRowDeleted;
			public event RoleRowChangeEventHandler RoleRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.RoleRowChanged?.Invoke(this, new RoleRowChangeEvent(((RoleRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.RoleRowChanging?.Invoke(this, new RoleRowChangeEvent(((RoleRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.RoleRowDeleted?.Invoke(this, new RoleRowChangeEvent(((RoleRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.RoleRowDeleting?.Invoke(this, new RoleRowChangeEvent(((RoleRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new RoleDataTable(Schema, Server);
			public RoleRow AddNewRow() => (RoleRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.Role);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new RoleRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region RoleRow
		[Thinkage.Libraries.Translation.Invariant]
		public class RoleRow : DBICustomDataRow<RoleDataTable> {
			#region Construction
			internal RoleRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly RoleDataTable this_table;
				private readonly RoleRow this_row;
				public FAccessor( RoleRow this_row )
				{
					this.this_table = ((RoleDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the Role's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.Role.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the Role's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
				/// </summary>
				public System.Guid PrincipalID {
					get {
							return (System.Guid)Schema.T.Role.F.PrincipalID.EffectiveType.GenericAsNativeType(this_table.F.PrincipalID[this_row], typeof(System.Guid));
					}
				}
			}
			#endregion
			#region Referenced-record accessors
			public PrincipalRow PrincipalIDParentRow => Table.DataSet.T.Principal.Rows.Find(F.PrincipalID);
			#endregion
			#region Referring-record accessors
			public IEnumerable<PrincipalRow> GetPrincipalRoleIDChildRows() => Table.DataSet.T.Principal.Rows.Where(r => Schema.T.Role.F.Id.EffectiveType.GenericEquals(r.F.RoleID, F.Id));
			#endregion
		}
		#endregion
		#region RoleRowChangeEvent
#if RoleRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class RoleRowChangeEvent : EventArgs {

			private RoleRow eventRow;

			private DataRowAction eventAction;

			public RoleRowChangeEvent(RoleRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public RoleRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region UserDataTable
		private bool ShouldSerializeUser() {
			return false;
		}
#if UserRowChangeEvents
		public delegate void UserRowChangeEventHandler(object sender, UserRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class UserDataTable : DBICustomDataTable<UserRow> {
			#region Construction
			internal UserDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal UserDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(UserDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.Id);
				  this.PrincipalID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.PrincipalID);
				  this.AuthenticationCredential = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.AuthenticationCredential);
				  this.Hidden = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.User.F.Hidden);
				}
				/// <summary>
				/// Denotes the User's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the User's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
				/// </summary>
				public readonly DBIDataColumn PrincipalID;
				/// <summary>
				/// Denotes the User's AuthenticationCredential column with type string(nonnull, minlength 1, maxlength 128, maxlines 0, trim) with labelkey='Authentication Credential'
				/// </summary>
				public readonly DBIDataColumn AuthenticationCredential;
				/// <summary>
				/// Denotes the User's Hidden column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='Hidden'
				/// </summary>
				public readonly DBIDataColumn Hidden;
			}
			#endregion
			#region EventHandlers
			#if UserRowChangeEvents
			public event UserRowChangeEventHandler UserRowChanged;
			public event UserRowChangeEventHandler UserRowChanging;
			public event UserRowChangeEventHandler UserRowDeleted;
			public event UserRowChangeEventHandler UserRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.UserRowChanged?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.UserRowChanging?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.UserRowDeleted?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.UserRowDeleting?.Invoke(this, new UserRowChangeEvent(((UserRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new UserDataTable(Schema, Server);
			public UserRow AddNewRow() => (UserRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.User);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new UserRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region UserRow
		[Thinkage.Libraries.Translation.Invariant]
		public class UserRow : DBICustomDataRow<UserDataTable> {
			#region Construction
			internal UserRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly UserDataTable this_table;
				private readonly UserRow this_row;
				public FAccessor( UserRow this_row )
				{
					this.this_table = ((UserDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the User's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.User.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the User's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
				/// </summary>
				public System.Guid PrincipalID {
					get {
							return (System.Guid)Schema.T.User.F.PrincipalID.EffectiveType.GenericAsNativeType(this_table.F.PrincipalID[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the User's AuthenticationCredential column with type string(nonnull, minlength 1, maxlength 128, maxlines 0, trim) with labelkey='Authentication Credential'
				/// </summary>
				public System.String AuthenticationCredential {
					get {
							return (System.String)Schema.T.User.F.AuthenticationCredential.EffectiveType.GenericAsNativeType(this_table.F.AuthenticationCredential[this_row], typeof(System.String));
					}
					set {this_table.F.AuthenticationCredential[this_row] = value; }
				}
				/// <summary>
				/// Denotes the User's Hidden column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='Hidden'
				/// </summary>
				public System.DateTime? Hidden {
					get {
							return (System.DateTime?)Schema.T.User.F.Hidden.EffectiveType.GenericAsNativeType(this_table.F.Hidden[this_row], typeof(System.DateTime?));
					}
					set {this_table.F.Hidden[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			public PrincipalRow PrincipalIDParentRow => Table.DataSet.T.Principal.Rows.Find(F.PrincipalID);
			#endregion
			#region Referring-record accessors
			public IEnumerable<UserRoleRow> GetUserRoleUserIDChildRows() => Table.DataSet.T.UserRole.Rows.Where(r => Schema.T.User.F.Id.EffectiveType.GenericEquals(r.F.UserID, F.Id));
			public IEnumerable<UserPermissionRow> GetUserPermissionUserIDChildRows() => Table.DataSet.T.UserPermission.Rows.Where(r => Schema.T.User.F.Id.EffectiveType.GenericEquals(r.F.UserID, F.Id));
			public IEnumerable<PrincipalRow> GetPrincipalUserIDChildRows() => Table.DataSet.T.Principal.Rows.Where(r => Schema.T.User.F.Id.EffectiveType.GenericEquals(r.F.UserID, F.Id));
			#endregion
		}
		#endregion
		#region UserRowChangeEvent
#if UserRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class UserRowChangeEvent : EventArgs {

			private UserRow eventRow;

			private DataRowAction eventAction;

			public UserRowChangeEvent(UserRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public UserRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region UserRoleDataTable
		private bool ShouldSerializeUserRole() {
			return false;
		}
#if UserRoleRowChangeEvents
		public delegate void UserRoleRowChangeEventHandler(object sender, UserRoleRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class UserRoleDataTable : DBICustomDataTable<UserRoleRow> {
			#region Construction
			internal UserRoleDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal UserRoleDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(UserRoleDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.UserRole.F.Id);
				  this.PrincipalID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.UserRole.F.PrincipalID);
				  this.UserID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.UserRole.F.UserID);
				}
				/// <summary>
				/// Denotes the UserRole's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the UserRole's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey='Role'
				/// </summary>
				public readonly DBIDataColumn PrincipalID;
				/// <summary>
				/// Denotes the UserRole's UserID column with type link(nonnull, field User.Id) with labelkey='User'
				/// </summary>
				public readonly DBIDataColumn UserID;
			}
			#endregion
			#region EventHandlers
			#if UserRoleRowChangeEvents
			public event UserRoleRowChangeEventHandler UserRoleRowChanged;
			public event UserRoleRowChangeEventHandler UserRoleRowChanging;
			public event UserRoleRowChangeEventHandler UserRoleRowDeleted;
			public event UserRoleRowChangeEventHandler UserRoleRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.UserRoleRowChanged?.Invoke(this, new UserRoleRowChangeEvent(((UserRoleRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.UserRoleRowChanging?.Invoke(this, new UserRoleRowChangeEvent(((UserRoleRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.UserRoleRowDeleted?.Invoke(this, new UserRoleRowChangeEvent(((UserRoleRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.UserRoleRowDeleting?.Invoke(this, new UserRoleRowChangeEvent(((UserRoleRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new UserRoleDataTable(Schema, Server);
			public UserRoleRow AddNewRow() => (UserRoleRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.UserRole);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new UserRoleRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region UserRoleRow
		[Thinkage.Libraries.Translation.Invariant]
		public class UserRoleRow : DBICustomDataRow<UserRoleDataTable> {
			#region Construction
			internal UserRoleRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly UserRoleDataTable this_table;
				private readonly UserRoleRow this_row;
				public FAccessor( UserRoleRow this_row )
				{
					this.this_table = ((UserRoleDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the UserRole's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.UserRole.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the UserRole's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey='Role'
				/// </summary>
				public System.Guid PrincipalID {
					get {
							return (System.Guid)Schema.T.UserRole.F.PrincipalID.EffectiveType.GenericAsNativeType(this_table.F.PrincipalID[this_row], typeof(System.Guid));
					}
					set {this_table.F.PrincipalID[this_row] = value; }
				}
				/// <summary>
				/// Denotes the UserRole's UserID column with type link(nonnull, field User.Id) with labelkey='User'
				/// </summary>
				public System.Guid UserID {
					get {
							return (System.Guid)Schema.T.UserRole.F.UserID.EffectiveType.GenericAsNativeType(this_table.F.UserID[this_row], typeof(System.Guid));
					}
					set {this_table.F.UserID[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			public PrincipalRow PrincipalIDParentRow => Table.DataSet.T.Principal.Rows.Find(F.PrincipalID);
			public UserRow UserIDParentRow => Table.DataSet.T.User.Rows.Find(F.UserID);
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region UserRoleRowChangeEvent
#if UserRoleRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class UserRoleRowChangeEvent : EventArgs {

			private UserRoleRow eventRow;

			private DataRowAction eventAction;

			public UserRoleRowChangeEvent(UserRoleRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public UserRoleRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region UserPermissionDataTable
		private bool ShouldSerializeUserPermission() {
			return false;
		}
#if UserPermissionRowChangeEvents
		public delegate void UserPermissionRowChangeEventHandler(object sender, UserPermissionRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class UserPermissionDataTable : DBICustomDataTable<UserPermissionRow> {
			#region Construction
			internal UserPermissionDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal UserPermissionDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(UserPermissionDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.UserPermission.F.Id);
				  this.UserID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.UserPermission.F.UserID);
				  this.PermissionPathPattern = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.UserPermission.F.PermissionPathPattern);
				}
				/// <summary>
				/// Denotes the UserPermission's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the UserPermission's UserID column with type link(nonnull, field User.Id) with labelkey='User'
				/// </summary>
				public readonly DBIDataColumn UserID;
				/// <summary>
				/// Denotes the UserPermission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
				/// </summary>
				public readonly DBIDataColumn PermissionPathPattern;
			}
			#endregion
			#region EventHandlers
			#if UserPermissionRowChangeEvents
			public event UserPermissionRowChangeEventHandler UserPermissionRowChanged;
			public event UserPermissionRowChangeEventHandler UserPermissionRowChanging;
			public event UserPermissionRowChangeEventHandler UserPermissionRowDeleted;
			public event UserPermissionRowChangeEventHandler UserPermissionRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.UserPermissionRowChanged?.Invoke(this, new UserPermissionRowChangeEvent(((UserPermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.UserPermissionRowChanging?.Invoke(this, new UserPermissionRowChangeEvent(((UserPermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.UserPermissionRowDeleted?.Invoke(this, new UserPermissionRowChangeEvent(((UserPermissionRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.UserPermissionRowDeleting?.Invoke(this, new UserPermissionRowChangeEvent(((UserPermissionRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new UserPermissionDataTable(Schema, Server);
			public UserPermissionRow AddNewRow() => (UserPermissionRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.UserPermission);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new UserPermissionRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region UserPermissionRow
		[Thinkage.Libraries.Translation.Invariant]
		public class UserPermissionRow : DBICustomDataRow<UserPermissionDataTable> {
			#region Construction
			internal UserPermissionRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly UserPermissionDataTable this_table;
				private readonly UserPermissionRow this_row;
				public FAccessor( UserPermissionRow this_row )
				{
					this.this_table = ((UserPermissionDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the UserPermission's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.UserPermission.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the UserPermission's UserID column with type link(nonnull, field User.Id) with labelkey='User'
				/// </summary>
				public System.Guid UserID {
					get {
							return (System.Guid)Schema.T.UserPermission.F.UserID.EffectiveType.GenericAsNativeType(this_table.F.UserID[this_row], typeof(System.Guid));
					}
					set {this_table.F.UserID[this_row] = value; }
				}
				/// <summary>
				/// Denotes the UserPermission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
				/// </summary>
				public System.String PermissionPathPattern {
					get {
							return (System.String)Schema.T.UserPermission.F.PermissionPathPattern.EffectiveType.GenericAsNativeType(this_table.F.PermissionPathPattern[this_row], typeof(System.String));
					}
					set {this_table.F.PermissionPathPattern[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			public UserRow UserIDParentRow => Table.DataSet.T.User.Rows.Find(F.UserID);
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region UserPermissionRowChangeEvent
#if UserPermissionRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class UserPermissionRowChangeEvent : EventArgs {

			private UserPermissionRow eventRow;

			private DataRowAction eventAction;

			public UserPermissionRowChangeEvent(UserPermissionRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public UserPermissionRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region LicenseDataTable
		private bool ShouldSerializeLicense() {
			return false;
		}
#if LicenseRowChangeEvents
		public delegate void LicenseRowChangeEventHandler(object sender, LicenseRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class LicenseDataTable : DBICustomDataTable<LicenseRow> {
			#region Construction
			internal LicenseDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal LicenseDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(LicenseDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.Id);
				  this.License = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.License);
				  this.ApplicationID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.ApplicationID);
				  this.Expiry = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.Expiry);
				  this.ExpiryModel = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.ExpiryModel);
				  this.LicenseCount = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.LicenseCount);
				  this.LicenseModel = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.LicenseModel);
				  this.LicenseID = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.License.F.LicenseID);
				}
				/// <summary>
				/// Denotes the License's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the License's License column with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) with labelkey='License'
				/// </summary>
				public readonly DBIDataColumn License;
				/// <summary>
				/// Denotes the License's ApplicationID column with type integer(nonnull, 32) with labelkey='Application'
				/// </summary>
				public readonly DBIDataColumn ApplicationID;
				/// <summary>
				/// Denotes the License's Expiry column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) with labelkey='Expiry'
				/// </summary>
				public readonly DBIDataColumn Expiry;
				/// <summary>
				/// Denotes the License's ExpiryModel column with type integer(nonnull, 16) with labelkey='ExpiryModel'
				/// </summary>
				public readonly DBIDataColumn ExpiryModel;
				/// <summary>
				/// Denotes the License's LicenseCount column with type integer(nonnull, 64) with labelkey='LicenseCount'
				/// </summary>
				public readonly DBIDataColumn LicenseCount;
				/// <summary>
				/// Denotes the License's LicenseModel column with type integer(nonnull, 16) with labelkey='LicenseModel'
				/// </summary>
				public readonly DBIDataColumn LicenseModel;
				/// <summary>
				/// Denotes the License's LicenseID column with type integer(nonnull, 64) with labelkey='License Id'
				/// </summary>
				public readonly DBIDataColumn LicenseID;
			}
			#endregion
			#region EventHandlers
			#if LicenseRowChangeEvents
			public event LicenseRowChangeEventHandler LicenseRowChanged;
			public event LicenseRowChangeEventHandler LicenseRowChanging;
			public event LicenseRowChangeEventHandler LicenseRowDeleted;
			public event LicenseRowChangeEventHandler LicenseRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.LicenseRowChanged?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.LicenseRowChanging?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.LicenseRowDeleted?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.LicenseRowDeleting?.Invoke(this, new LicenseRowChangeEvent(((LicenseRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new LicenseDataTable(Schema, Server);
			public LicenseRow AddNewRow() => (LicenseRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.License);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new LicenseRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region LicenseRow
		[Thinkage.Libraries.Translation.Invariant]
		public class LicenseRow : DBICustomDataRow<LicenseDataTable> {
			#region Construction
			internal LicenseRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly LicenseDataTable this_table;
				private readonly LicenseRow this_row;
				public FAccessor( LicenseRow this_row )
				{
					this.this_table = ((LicenseDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the License's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.License.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the License's License column with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) with labelkey='License'
				/// </summary>
				public System.String License {
					get {
							return (System.String)Schema.T.License.F.License.EffectiveType.GenericAsNativeType(this_table.F.License[this_row], typeof(System.String));
					}
					set {this_table.F.License[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's ApplicationID column with type integer(nonnull, 32) with labelkey='Application'
				/// </summary>
				public System.Int32 ApplicationID {
					get {
							return (System.Int32)Schema.T.License.F.ApplicationID.EffectiveType.GenericAsNativeType(this_table.F.ApplicationID[this_row], typeof(System.Int32));
					}
					set {this_table.F.ApplicationID[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's Expiry column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) with labelkey='Expiry'
				/// </summary>
				public System.DateTime? Expiry {
					get {
							return (System.DateTime?)Schema.T.License.F.Expiry.EffectiveType.GenericAsNativeType(this_table.F.Expiry[this_row], typeof(System.DateTime?));
					}
					set {this_table.F.Expiry[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's ExpiryModel column with type integer(nonnull, 16) with labelkey='ExpiryModel'
				/// </summary>
				public System.Int16 ExpiryModel {
					get {
							return (System.Int16)Schema.T.License.F.ExpiryModel.EffectiveType.GenericAsNativeType(this_table.F.ExpiryModel[this_row], typeof(System.Int16));
					}
					set {this_table.F.ExpiryModel[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseCount column with type integer(nonnull, 64) with labelkey='LicenseCount'
				/// </summary>
				public System.Int64 LicenseCount {
					get {
							return (System.Int64)Schema.T.License.F.LicenseCount.EffectiveType.GenericAsNativeType(this_table.F.LicenseCount[this_row], typeof(System.Int64));
					}
					set {this_table.F.LicenseCount[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseModel column with type integer(nonnull, 16) with labelkey='LicenseModel'
				/// </summary>
				public System.Int16 LicenseModel {
					get {
							return (System.Int16)Schema.T.License.F.LicenseModel.EffectiveType.GenericAsNativeType(this_table.F.LicenseModel[this_row], typeof(System.Int16));
					}
					set {this_table.F.LicenseModel[this_row] = value; }
				}
				/// <summary>
				/// Denotes the License's LicenseID column with type integer(nonnull, 64) with labelkey='License Id'
				/// </summary>
				public System.Int64 LicenseID {
					get {
							return (System.Int64)Schema.T.License.F.LicenseID.EffectiveType.GenericAsNativeType(this_table.F.LicenseID[this_row], typeof(System.Int64));
					}
					set {this_table.F.LicenseID[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region LicenseRowChangeEvent
#if LicenseRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class LicenseRowChangeEvent : EventArgs {

			private LicenseRow eventRow;

			private DataRowAction eventAction;

			public LicenseRowChangeEvent(LicenseRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public LicenseRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region DatabaseHistoryDataTable
		private bool ShouldSerializeDatabaseHistory() {
			return false;
		}
#if DatabaseHistoryRowChangeEvents
		public delegate void DatabaseHistoryRowChangeEventHandler(object sender, DatabaseHistoryRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class DatabaseHistoryDataTable : DBICustomDataTable<DatabaseHistoryRow> {
			#region Construction
			internal DatabaseHistoryDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal DatabaseHistoryDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(DatabaseHistoryDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory.F.Id);
				  this.EntryDate = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory.F.EntryDate);
				  this.Subject = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory.F.Subject);
				  this.Description = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.DatabaseHistory.F.Description);
				}
				/// <summary>
				/// Denotes the DatabaseHistory's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the DatabaseHistory's EntryDate column with type datetime(nonnull, (min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='EntryDate'
				/// </summary>
				public readonly DBIDataColumn EntryDate;
				/// <summary>
				/// Denotes the DatabaseHistory's Subject column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='Subject'
				/// </summary>
				public readonly DBIDataColumn Subject;
				/// <summary>
				/// Denotes the DatabaseHistory's Description column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Description'
				/// </summary>
				public readonly DBIDataColumn Description;
			}
			#endregion
			#region EventHandlers
			#if DatabaseHistoryRowChangeEvents
			public event DatabaseHistoryRowChangeEventHandler DatabaseHistoryRowChanged;
			public event DatabaseHistoryRowChangeEventHandler DatabaseHistoryRowChanging;
			public event DatabaseHistoryRowChangeEventHandler DatabaseHistoryRowDeleted;
			public event DatabaseHistoryRowChangeEventHandler DatabaseHistoryRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.DatabaseHistoryRowChanged?.Invoke(this, new DatabaseHistoryRowChangeEvent(((DatabaseHistoryRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.DatabaseHistoryRowChanging?.Invoke(this, new DatabaseHistoryRowChangeEvent(((DatabaseHistoryRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.DatabaseHistoryRowDeleted?.Invoke(this, new DatabaseHistoryRowChangeEvent(((DatabaseHistoryRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.DatabaseHistoryRowDeleting?.Invoke(this, new DatabaseHistoryRowChangeEvent(((DatabaseHistoryRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new DatabaseHistoryDataTable(Schema, Server);
			public DatabaseHistoryRow AddNewRow() => (DatabaseHistoryRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.DatabaseHistory);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new DatabaseHistoryRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region DatabaseHistoryRow
		[Thinkage.Libraries.Translation.Invariant]
		public class DatabaseHistoryRow : DBICustomDataRow<DatabaseHistoryDataTable> {
			#region Construction
			internal DatabaseHistoryRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly DatabaseHistoryDataTable this_table;
				private readonly DatabaseHistoryRow this_row;
				public FAccessor( DatabaseHistoryRow this_row )
				{
					this.this_table = ((DatabaseHistoryDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the DatabaseHistory's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.DatabaseHistory.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the DatabaseHistory's EntryDate column with type datetime(nonnull, (min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='EntryDate'
				/// </summary>
				public System.DateTime EntryDate {
					get {
							return (System.DateTime)Schema.T.DatabaseHistory.F.EntryDate.EffectiveType.GenericAsNativeType(this_table.F.EntryDate[this_row], typeof(System.DateTime));
					}
					set {this_table.F.EntryDate[this_row] = value; }
				}
				/// <summary>
				/// Denotes the DatabaseHistory's Subject column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='Subject'
				/// </summary>
				public System.String Subject {
					get {
							return (System.String)Schema.T.DatabaseHistory.F.Subject.EffectiveType.GenericAsNativeType(this_table.F.Subject[this_row], typeof(System.String));
					}
					set {this_table.F.Subject[this_row] = value; }
				}
				/// <summary>
				/// Denotes the DatabaseHistory's Description column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Description'
				/// </summary>
				public System.String Description {
					get {
							return (System.String)Schema.T.DatabaseHistory.F.Description.EffectiveType.GenericAsNativeType(this_table.F.Description[this_row], typeof(System.String));
					}
					set {this_table.F.Description[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region DatabaseHistoryRowChangeEvent
#if DatabaseHistoryRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class DatabaseHistoryRowChangeEvent : EventArgs {

			private DatabaseHistoryRow eventRow;

			private DataRowAction eventAction;

			public DatabaseHistoryRowChangeEvent(DatabaseHistoryRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public DatabaseHistoryRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#region BackupFileNameDataTable
		private bool ShouldSerializeBackupFileName() {
			return false;
		}
#if BackupFileNameRowChangeEvents
		public delegate void BackupFileNameRowChangeEventHandler(object sender, BackupFileNameRowChangeEvent e);
#endif

		[Thinkage.Libraries.Translation.Invariant]
		public class BackupFileNameDataTable : DBICustomDataTable<BackupFileNameRow> {
			#region Construction
			internal BackupFileNameDataTable(DBI_Table tableSchema, IServer s) :
					base(tableSchema, s) {
				Columns.CollectionChanged += delegate(object sender, System.ComponentModel.CollectionChangeEventArgs ea) {
					_F = null;
				};
			}
#if SerializationSupport
			internal BackupFileNameDataTable(System.Data.DataTable table) :
					base(table.TableName) {
				if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
					this.CaseSensitive = table.CaseSensitive;
				}
				if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
					this.Locale = table.Locale;
				}
				if ((table.Namespace != table.DataSet.Namespace)) {
					this.Namespace = table.Namespace;
				}
				this.Prefix = table.Prefix;
				this.MinimumCapacity = table.MinimumCapacity;
			}
#endif
			#endregion
			#region Typed Column accessor
			internal FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			internal class FAccessor {
				public FAccessor(BackupFileNameDataTable t) {
				  this.Id = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.BackupFileName.F.Id);
				  this.LastBackupDate = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.BackupFileName.F.LastBackupDate);
				  this.FileName = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.BackupFileName.F.FileName);
				  this.Comment = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.BackupFileName.F.Comment);
				  this.Message = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.BackupFileName.F.Message);
				  this.DatabaseVersion = t.Columns.FindColumnDuringTableConstruction(SchemaClass.Instance.T.BackupFileName.F.DatabaseVersion);
				}
				/// <summary>
				/// Denotes the BackupFileName's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public readonly DBIDataColumn Id;
				/// <summary>
				/// Denotes the BackupFileName's LastBackupDate column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='LastBackupDate'
				/// </summary>
				public readonly DBIDataColumn LastBackupDate;
				/// <summary>
				/// Denotes the BackupFileName's FileName column with type string(nonnull, minlength 1, maxlength 256, maxlines 0, trim) with labelkey='FileName'
				/// </summary>
				public readonly DBIDataColumn FileName;
				/// <summary>
				/// Denotes the BackupFileName's Comment column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Comment'
				/// </summary>
				public readonly DBIDataColumn Comment;
				/// <summary>
				/// Denotes the BackupFileName's Message column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Message'
				/// </summary>
				public readonly DBIDataColumn Message;
				/// <summary>
				/// Denotes the BackupFileName's DatabaseVersion column with type string(minlength 1, maxlength 23, maxlines 0) with labelkey='DatabaseVersion'
				/// </summary>
				public readonly DBIDataColumn DatabaseVersion;
			}
			#endregion
			#region EventHandlers
			#if BackupFileNameRowChangeEvents
			public event BackupFileNameRowChangeEventHandler BackupFileNameRowChanged;
			public event BackupFileNameRowChangeEventHandler BackupFileNameRowChanging;
			public event BackupFileNameRowChangeEventHandler BackupFileNameRowDeleted;
			public event BackupFileNameRowChangeEventHandler BackupFileNameRowDeleting;

			protected override void OnRowChanged(DataRowChangeEventArgs e) {
				base.OnRowChanged(e);
				this.BackupFileNameRowChanged?.Invoke(this, new BackupFileNameRowChangeEvent(((BackupFileNameRow)(e.Row)), e.Action));
			}
			protected override void OnRowChanging(DataRowChangeEventArgs e) {
				base.OnRowChanging(e);
				this.BackupFileNameRowChanging?.Invoke(this, new BackupFileNameRowChangeEvent(((BackupFileNameRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleted(DataRowChangeEventArgs e) {
				base.OnRowDeleted(e);
				this.BackupFileNameRowDeleted?.Invoke(this, new BackupFileNameRowChangeEvent(((BackupFileNameRow)(e.Row)), e.Action));
			}
			protected override void OnRowDeleting(DataRowChangeEventArgs e) {
				base.OnRowDeleting(e);
				this.BackupFileNameRowDeleting?.Invoke(this, new BackupFileNameRowChangeEvent(((BackupFileNameRow)(e.Row)), e.Action));
			}
			#endif
			#endregion
			protected override DBIDataTable CreateDBIInstance() => new BackupFileNameDataTable(Schema, Server);
			public BackupFileNameRow AddNewRow() => (BackupFileNameRow)DataSet.DB.AddNewRowAndBasesForGeneratedClass(DataSet, dsUpgrade_1_1_4_2.Schema.T.BackupFileName);
			protected override DBIDataRow NewDBIRowFromBuilder(System.Data.DataRowBuilder builder) => new BackupFileNameRow(builder);
			public new dsUpgrade_1_1_4_2 DataSet => (dsUpgrade_1_1_4_2)base.DataSet;
		}
		#region BackupFileNameRow
		[Thinkage.Libraries.Translation.Invariant]
		public class BackupFileNameRow : DBICustomDataRow<BackupFileNameDataTable> {
			#region Construction
			internal BackupFileNameRow(System.Data.DataRowBuilder rb)
				: base(rb) {
			}
			#endregion
			#region Typed Column accessor
			public FAccessor F {
				get {
					if (_F == null)
						_F = new FAccessor(this);
					return _F;
				}
			}
			private FAccessor _F = null;
			[Thinkage.Libraries.Translation.Invariant]
			public class FAccessor {
				private readonly BackupFileNameDataTable this_table;
				private readonly BackupFileNameRow this_row;
				public FAccessor( BackupFileNameRow this_row )
				{
					this.this_table = ((BackupFileNameDataTable)(this_row.Table));
					this.this_row = this_row;
				}
				/// <summary>
				/// Denotes the BackupFileName's Id column with type id(nonnull) with labelkey='Id'
				/// </summary>
				public System.Guid Id {
					get {
							return (System.Guid)Schema.T.BackupFileName.F.Id.EffectiveType.GenericAsNativeType(this_table.F.Id[this_row], typeof(System.Guid));
					}
				}
				/// <summary>
				/// Denotes the BackupFileName's LastBackupDate column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='LastBackupDate'
				/// </summary>
				public System.DateTime? LastBackupDate {
					get {
							return (System.DateTime?)Schema.T.BackupFileName.F.LastBackupDate.EffectiveType.GenericAsNativeType(this_table.F.LastBackupDate[this_row], typeof(System.DateTime?));
					}
					set {this_table.F.LastBackupDate[this_row] = value; }
				}
				/// <summary>
				/// Denotes the BackupFileName's FileName column with type string(nonnull, minlength 1, maxlength 256, maxlines 0, trim) with labelkey='FileName'
				/// </summary>
				public System.String FileName {
					get {
							return (System.String)Schema.T.BackupFileName.F.FileName.EffectiveType.GenericAsNativeType(this_table.F.FileName[this_row], typeof(System.String));
					}
					set {this_table.F.FileName[this_row] = value; }
				}
				/// <summary>
				/// Denotes the BackupFileName's Comment column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Comment'
				/// </summary>
				public System.String Comment {
					get {
							return (System.String)Schema.T.BackupFileName.F.Comment.EffectiveType.GenericAsNativeType(this_table.F.Comment[this_row], typeof(System.String));
					}
					set {this_table.F.Comment[this_row] = value; }
				}
				/// <summary>
				/// Denotes the BackupFileName's Message column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Message'
				/// </summary>
				public System.String Message {
					get {
							return (System.String)Schema.T.BackupFileName.F.Message.EffectiveType.GenericAsNativeType(this_table.F.Message[this_row], typeof(System.String));
					}
					set {this_table.F.Message[this_row] = value; }
				}
				/// <summary>
				/// Denotes the BackupFileName's DatabaseVersion column with type string(minlength 1, maxlength 23, maxlines 0) with labelkey='DatabaseVersion'
				/// </summary>
				public System.String DatabaseVersion {
					get {
							return (System.String)Schema.T.BackupFileName.F.DatabaseVersion.EffectiveType.GenericAsNativeType(this_table.F.DatabaseVersion[this_row], typeof(System.String));
					}
					set {this_table.F.DatabaseVersion[this_row] = value; }
				}
			}
			#endregion
			#region Referenced-record accessors
			#endregion
			#region Referring-record accessors
			#endregion
		}
		#endregion
		#region BackupFileNameRowChangeEvent
#if BackupFileNameRowChangeEvents
		[Thinkage.Libraries.Translation.Invariant]
		public class BackupFileNameRowChangeEvent : EventArgs {

			private BackupFileNameRow eventRow;

			private DataRowAction eventAction;

			public BackupFileNameRowChangeEvent(BackupFileNameRow row, DataRowAction action) {
				this.eventRow = row;
				this.eventAction = action;
			}

			public BackupFileNameRow Row {
				get {
					return this.eventRow;
				}
			}

			public DataRowAction Action {
				get {
					return this.eventAction;
				}
			}
		}
#endif
		#endregion
		#endregion
		#endregion

		#region Custom database schema definitions
		#region - the custom Schema class
		/// <summary>
		/// Singleton class containing the schema of all tables,
		/// columns, and relationships in a database.
		/// </summary>
		[Thinkage.Libraries.Translation.Invariant]
		public class SchemaClass : DBI_Database {
			#region singleton construction
			private SchemaClass() {
				_T = new TAccessor(this);
				vstruct = new VAccessor(this);
				__Permission = new DBI_Permission();
				Tables.Add( __Permission);
				__Principal = new DBI_Principal();
				Tables.Add( __Principal);
				__Role = new DBI_Role();
				Tables.Add( __Role);
				__User = new DBI_User();
				Tables.Add( __User);
				__UserRole = new DBI_UserRole();
				Tables.Add( __UserRole);
				__UserPermission = new DBI_UserPermission();
				Tables.Add( __UserPermission);
				__License = new DBI_License();
				Tables.Add( __License);
				__DatabaseHistory = new DBI_DatabaseHistory();
				Tables.Add( __DatabaseHistory);
				__BackupFileName = new DBI_BackupFileName();
				Tables.Add( __BackupFileName);
				CompleteDBI(System.Reflection.Assembly.GetExecutingAssembly(), "manifest://localhost/Thinkage/MainBoss/Database/Upgrade/Schema/dsUpgrade_1_1_4_2.xafdb", typeof(dsUpgrade_1_1_4_2)
				);
				__VDBVersion = Variables["DBVersion"];
				System.Diagnostics.Debug.Assert(__VDBVersion != null, "Variable 'DBVersion' not found");
				__VDBServerVersion = Variables["DBServerVersion"];
				System.Diagnostics.Debug.Assert(__VDBServerVersion != null, "Variable 'DBServerVersion' not found");
			 }
			/// <summary>
			/// The instantiation of the singleton SchemaClass object
			/// </summary>
			public static readonly SchemaClass Instance = new SchemaClass();
			#endregion
			#region Custom DBI_Table derivations and their private reference in the schema object
			#region - Permission table
			private DBI_Permission __Permission;

			/// <summary>
			/// Class to describe a Permission table
			/// </summary>
			public class DBI_Permission : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __PrincipalID;
				private DBI_Column __PermissionPathPattern;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_Permission this_table;
					public FAccessor( DBI_Permission this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the Permission's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the Permission's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
					/// </summary>
					public DBI_Column PrincipalID { get { return this_table.__PrincipalID; } }
					/// <summary>
					/// Denotes the Permission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
					/// </summary>
					public DBI_Column PermissionPathPattern { get { return this_table.__PermissionPathPattern; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_Permission()
					: base("Permission", (DBI_Table tableSchema, IServer s) => new PermissionDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 3, "Table 'Permission' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__PrincipalID = Columns["PrincipalID"];
					System.Diagnostics.Debug.Assert(__PrincipalID != null, "Column 'PrincipalID' not found");
					__PermissionPathPattern = Columns["PermissionPathPattern"];
					System.Diagnostics.Debug.Assert(__PermissionPathPattern != null, "Column 'PermissionPathPattern' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - Principal table
			private DBI_Principal __Principal;

			/// <summary>
			/// Class to describe a Principal table
			/// </summary>
			public class DBI_Principal : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __RoleID;
				private DBI_Column __UserID;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_Principal this_table;
					public FAccessor( DBI_Principal this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the Principal's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the Principal's RoleID column with type link(field Role.Id) with labelkey='Role'
					/// </summary>
					public DBI_Column RoleID { get { return this_table.__RoleID; } }
					/// <summary>
					/// Denotes the Principal's UserID column with type link(field User.Id) with labelkey='User'
					/// </summary>
					public DBI_Column UserID { get { return this_table.__UserID; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_Principal()
					: base("Principal", (DBI_Table tableSchema, IServer s) => new PrincipalDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 3, "Table 'Principal' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__RoleID = Columns["RoleID"];
					System.Diagnostics.Debug.Assert(__RoleID != null, "Column 'RoleID' not found");
					__UserID = Columns["UserID"];
					System.Diagnostics.Debug.Assert(__UserID != null, "Column 'UserID' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - Role table
			private DBI_Role __Role;

			/// <summary>
			/// Class to describe a Role table
			/// </summary>
			public class DBI_Role : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __PrincipalID;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_Role this_table;
					public FAccessor( DBI_Role this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the Role's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the Role's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
					/// </summary>
					public DBI_Column PrincipalID { get { return this_table.__PrincipalID; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_Role()
					: base("Role", (DBI_Table tableSchema, IServer s) => new RoleDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 2, "Table 'Role' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__PrincipalID = Columns["PrincipalID"];
					System.Diagnostics.Debug.Assert(__PrincipalID != null, "Column 'PrincipalID' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - User table
			private DBI_User __User;

			/// <summary>
			/// Class to describe a User table
			/// </summary>
			public class DBI_User : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __PrincipalID;
				private DBI_Column __AuthenticationCredential;
				private DBI_Column __Hidden;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_User this_table;
					public FAccessor( DBI_User this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the User's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the User's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey=''
					/// </summary>
					public DBI_Column PrincipalID { get { return this_table.__PrincipalID; } }
					/// <summary>
					/// Denotes the User's AuthenticationCredential column with type string(nonnull, minlength 1, maxlength 128, maxlines 0, trim) with labelkey='Authentication Credential'
					/// </summary>
					public DBI_Column AuthenticationCredential { get { return this_table.__AuthenticationCredential; } }
					/// <summary>
					/// Denotes the User's Hidden column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='Hidden'
					/// </summary>
					public DBI_Column Hidden { get { return this_table.__Hidden; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_User()
					: base("User", (DBI_Table tableSchema, IServer s) => new UserDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 4, "Table 'User' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__PrincipalID = Columns["PrincipalID"];
					System.Diagnostics.Debug.Assert(__PrincipalID != null, "Column 'PrincipalID' not found");
					__AuthenticationCredential = Columns["AuthenticationCredential"];
					System.Diagnostics.Debug.Assert(__AuthenticationCredential != null, "Column 'AuthenticationCredential' not found");
					__Hidden = Columns["Hidden"];
					System.Diagnostics.Debug.Assert(__Hidden != null, "Column 'Hidden' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - UserRole table
			private DBI_UserRole __UserRole;

			/// <summary>
			/// Class to describe a UserRole table
			/// </summary>
			public class DBI_UserRole : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __PrincipalID;
				private DBI_Column __UserID;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_UserRole this_table;
					public FAccessor( DBI_UserRole this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the UserRole's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the UserRole's PrincipalID column with type link(nonnull, field Principal.Id) with labelkey='Role'
					/// </summary>
					public DBI_Column PrincipalID { get { return this_table.__PrincipalID; } }
					/// <summary>
					/// Denotes the UserRole's UserID column with type link(nonnull, field User.Id) with labelkey='User'
					/// </summary>
					public DBI_Column UserID { get { return this_table.__UserID; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_UserRole()
					: base("UserRole", (DBI_Table tableSchema, IServer s) => new UserRoleDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 3, "Table 'UserRole' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__PrincipalID = Columns["PrincipalID"];
					System.Diagnostics.Debug.Assert(__PrincipalID != null, "Column 'PrincipalID' not found");
					__UserID = Columns["UserID"];
					System.Diagnostics.Debug.Assert(__UserID != null, "Column 'UserID' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - UserPermission table
			private DBI_UserPermission __UserPermission;

			/// <summary>
			/// Class to describe a UserPermission table
			/// </summary>
			public class DBI_UserPermission : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __UserID;
				private DBI_Column __PermissionPathPattern;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_UserPermission this_table;
					public FAccessor( DBI_UserPermission this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the UserPermission's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the UserPermission's UserID column with type link(nonnull, field User.Id) with labelkey='User'
					/// </summary>
					public DBI_Column UserID { get { return this_table.__UserID; } }
					/// <summary>
					/// Denotes the UserPermission's PermissionPathPattern column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='PermissionPathPattern'
					/// </summary>
					public DBI_Column PermissionPathPattern { get { return this_table.__PermissionPathPattern; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_UserPermission()
					: base("UserPermission", (DBI_Table tableSchema, IServer s) => new UserPermissionDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 3, "Table 'UserPermission' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__UserID = Columns["UserID"];
					System.Diagnostics.Debug.Assert(__UserID != null, "Column 'UserID' not found");
					__PermissionPathPattern = Columns["PermissionPathPattern"];
					System.Diagnostics.Debug.Assert(__PermissionPathPattern != null, "Column 'PermissionPathPattern' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - License table
			private DBI_License __License;

			/// <summary>
			/// Class to describe a License table
			/// </summary>
			public class DBI_License : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __License;
				private DBI_Column __ApplicationID;
				private DBI_Column __Expiry;
				private DBI_Column __ExpiryModel;
				private DBI_Column __LicenseCount;
				private DBI_Column __LicenseModel;
				private DBI_Column __LicenseID;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_License this_table;
					public FAccessor( DBI_License this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the License's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the License's License column with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) with labelkey='License'
					/// </summary>
					public DBI_Column License { get { return this_table.__License; } }
					/// <summary>
					/// Denotes the License's ApplicationID column with type integer(nonnull, 32) with labelkey='Application'
					/// </summary>
					public DBI_Column ApplicationID { get { return this_table.__ApplicationID; } }
					/// <summary>
					/// Denotes the License's Expiry column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) with labelkey='Expiry'
					/// </summary>
					public DBI_Column Expiry { get { return this_table.__Expiry; } }
					/// <summary>
					/// Denotes the License's ExpiryModel column with type integer(nonnull, 16) with labelkey='ExpiryModel'
					/// </summary>
					public DBI_Column ExpiryModel { get { return this_table.__ExpiryModel; } }
					/// <summary>
					/// Denotes the License's LicenseCount column with type integer(nonnull, 64) with labelkey='LicenseCount'
					/// </summary>
					public DBI_Column LicenseCount { get { return this_table.__LicenseCount; } }
					/// <summary>
					/// Denotes the License's LicenseModel column with type integer(nonnull, 16) with labelkey='LicenseModel'
					/// </summary>
					public DBI_Column LicenseModel { get { return this_table.__LicenseModel; } }
					/// <summary>
					/// Denotes the License's LicenseID column with type integer(nonnull, 64) with labelkey='License Id'
					/// </summary>
					public DBI_Column LicenseID { get { return this_table.__LicenseID; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_License()
					: base("License", (DBI_Table tableSchema, IServer s) => new LicenseDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 8, "Table 'License' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__License = Columns["License"];
					System.Diagnostics.Debug.Assert(__License != null, "Column 'License' not found");
					__ApplicationID = Columns["ApplicationID"];
					System.Diagnostics.Debug.Assert(__ApplicationID != null, "Column 'ApplicationID' not found");
					__Expiry = Columns["Expiry"];
					System.Diagnostics.Debug.Assert(__Expiry != null, "Column 'Expiry' not found");
					__ExpiryModel = Columns["ExpiryModel"];
					System.Diagnostics.Debug.Assert(__ExpiryModel != null, "Column 'ExpiryModel' not found");
					__LicenseCount = Columns["LicenseCount"];
					System.Diagnostics.Debug.Assert(__LicenseCount != null, "Column 'LicenseCount' not found");
					__LicenseModel = Columns["LicenseModel"];
					System.Diagnostics.Debug.Assert(__LicenseModel != null, "Column 'LicenseModel' not found");
					__LicenseID = Columns["LicenseID"];
					System.Diagnostics.Debug.Assert(__LicenseID != null, "Column 'LicenseID' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - DatabaseHistory table
			private DBI_DatabaseHistory __DatabaseHistory;

			/// <summary>
			/// Class to describe a DatabaseHistory table
			/// </summary>
			public class DBI_DatabaseHistory : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __EntryDate;
				private DBI_Column __Subject;
				private DBI_Column __Description;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_DatabaseHistory this_table;
					public FAccessor( DBI_DatabaseHistory this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the DatabaseHistory's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the DatabaseHistory's EntryDate column with type datetime(nonnull, (min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='EntryDate'
					/// </summary>
					public DBI_Column EntryDate { get { return this_table.__EntryDate; } }
					/// <summary>
					/// Denotes the DatabaseHistory's Subject column with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) with labelkey='Subject'
					/// </summary>
					public DBI_Column Subject { get { return this_table.__Subject; } }
					/// <summary>
					/// Denotes the DatabaseHistory's Description column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Description'
					/// </summary>
					public DBI_Column Description { get { return this_table.__Description; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_DatabaseHistory()
					: base("DatabaseHistory", (DBI_Table tableSchema, IServer s) => new DatabaseHistoryDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 4, "Table 'DatabaseHistory' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__EntryDate = Columns["EntryDate"];
					System.Diagnostics.Debug.Assert(__EntryDate != null, "Column 'EntryDate' not found");
					__Subject = Columns["Subject"];
					System.Diagnostics.Debug.Assert(__Subject != null, "Column 'Subject' not found");
					__Description = Columns["Description"];
					System.Diagnostics.Debug.Assert(__Description != null, "Column 'Description' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#region - BackupFileName table
			private DBI_BackupFileName __BackupFileName;

			/// <summary>
			/// Class to describe a BackupFileName table
			/// </summary>
			public class DBI_BackupFileName : DBIDataDBI_Table {
				public FAccessor F;
				private DBI_Column __Id;
				private DBI_Column __LastBackupDate;
				private DBI_Column __FileName;
				private DBI_Column __Comment;
				private DBI_Column __Message;
				private DBI_Column __DatabaseVersion;
				[Thinkage.Libraries.Translation.Invariant]
				public struct FAccessor {
					private DBI_BackupFileName this_table;
					public FAccessor( DBI_BackupFileName this_table )
					{
						this.this_table = this_table;
					}
					/// <summary>
					/// Denotes the BackupFileName's Id column with type id(nonnull) with labelkey='Id'
					/// </summary>
					public DBI_Column Id { get { return this_table.__Id; } }
					/// <summary>
					/// Denotes the BackupFileName's LastBackupDate column with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) with labelkey='LastBackupDate'
					/// </summary>
					public DBI_Column LastBackupDate { get { return this_table.__LastBackupDate; } }
					/// <summary>
					/// Denotes the BackupFileName's FileName column with type string(nonnull, minlength 1, maxlength 256, maxlines 0, trim) with labelkey='FileName'
					/// </summary>
					public DBI_Column FileName { get { return this_table.__FileName; } }
					/// <summary>
					/// Denotes the BackupFileName's Comment column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Comment'
					/// </summary>
					public DBI_Column Comment { get { return this_table.__Comment; } }
					/// <summary>
					/// Denotes the BackupFileName's Message column with type string(minlength 1, (maxlength 1,073,741,823), trim) with labelkey='Message'
					/// </summary>
					public DBI_Column Message { get { return this_table.__Message; } }
					/// <summary>
					/// Denotes the BackupFileName's DatabaseVersion column with type string(minlength 1, maxlength 23, maxlines 0) with labelkey='DatabaseVersion'
					/// </summary>
					public DBI_Column DatabaseVersion { get { return this_table.__DatabaseVersion; } }
				}

				/// <summary>
				/// Internal table constructor
				/// </summary>
				internal DBI_BackupFileName()
					: base("BackupFileName", (DBI_Table tableSchema, IServer s) => new BackupFileNameDataTable(tableSchema, s)) {
				}

				/// <summary>
				/// Custom-table-class member variable initialization
				/// </summary>
				public override void SetupVariables() {
					// The columns are predefined by the Xml load. In theory they are in the same order as when this file
					// was built and we could find them by index, but finding them by name is more bullet-proof.
					System.Diagnostics.Debug.Assert(Columns.Count == 6, "Table 'BackupFileName' column count mismatch");
					__Id = Columns["Id"];
					System.Diagnostics.Debug.Assert(__Id != null, "Column 'Id' not found");
					__LastBackupDate = Columns["LastBackupDate"];
					System.Diagnostics.Debug.Assert(__LastBackupDate != null, "Column 'LastBackupDate' not found");
					__FileName = Columns["FileName"];
					System.Diagnostics.Debug.Assert(__FileName != null, "Column 'FileName' not found");
					__Comment = Columns["Comment"];
					System.Diagnostics.Debug.Assert(__Comment != null, "Column 'Comment' not found");
					__Message = Columns["Message"];
					System.Diagnostics.Debug.Assert(__Message != null, "Column 'Message' not found");
					__DatabaseVersion = Columns["DatabaseVersion"];
					System.Diagnostics.Debug.Assert(__DatabaseVersion != null, "Column 'DatabaseVersion' not found");
					F = new FAccessor(this);
				}
			}
			#endregion
			#endregion
			#region T - the public portal for getting the custom-typed DBI_Table objects for each table
			public struct TAccessor {
				private SchemaClass this_schema;
				public TAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Accessors
				/// <summary>
				/// Denotes the Permission table with labelkey='Permission'
				/// </summary>
				public DBI_Permission Permission { get { return this_schema.__Permission; }}
				/// <summary>
				/// Denotes the Principal table with labelkey=''
				/// </summary>
				public DBI_Principal Principal { get { return this_schema.__Principal; }}
				/// <summary>
				/// Denotes the Role table with labelkey='Role'
				/// </summary>
				public DBI_Role Role { get { return this_schema.__Role; }}
				/// <summary>
				/// Denotes the User table with labelkey='User'
				/// </summary>
				public DBI_User User { get { return this_schema.__User; }}
				/// <summary>
				/// Denotes the UserRole table with labelkey=''
				/// </summary>
				public DBI_UserRole UserRole { get { return this_schema.__UserRole; }}
				/// <summary>
				/// Denotes the UserPermission table with labelkey=''
				/// </summary>
				public DBI_UserPermission UserPermission { get { return this_schema.__UserPermission; }}
				/// <summary>
				/// Denotes the License table with labelkey='License'
				/// </summary>
				public DBI_License License { get { return this_schema.__License; }}
				/// <summary>
				/// Denotes the DatabaseHistory table with labelkey='Database History'
				/// </summary>
				public DBI_DatabaseHistory DatabaseHistory { get { return this_schema.__DatabaseHistory; }}
				/// <summary>
				/// Denotes the BackupFileName table with labelkey='BackupFileName'
				/// </summary>
				public DBI_BackupFileName BackupFileName { get { return this_schema.__BackupFileName; }}
				#endregion
			}
			public TAccessor T { get { return _T; } }
			private TAccessor _T;
			#endregion
			#region V - the public portal for getting the DBI_Variable objects for Database Variables
			private DBI_Variable __VDBVersion;
			private DBI_Variable __VDBServerVersion;
			public struct VAccessor {
				private SchemaClass this_schema;
				public VAccessor( SchemaClass this_schema )
				{
					this.this_schema = this_schema;
				}
				#region Variable Accessors
				/// <summary>
				/// Denotes the Database DBVersion variable
				/// </summary>
				public DBI_Variable DBVersion { get { return this_schema.__VDBVersion; } }
				/// <summary>
				/// Denotes the Database DBServerVersion variable
				/// </summary>
				public DBI_Variable DBServerVersion { get { return this_schema.__VDBServerVersion; } }
				#endregion
			}
			public VAccessor V { get { return vstruct; } }	// Variables
			private VAccessor vstruct;
			#endregion
		}
		#endregion
		#region - The static member that contains the Schema
		public readonly static SchemaClass Schema = SchemaClass.Instance;
		// make a member variable in the class for reference in a dynamic type instance of this object
		public readonly SchemaClass SchemaDynamic = Schema;
		#endregion
		#endregion
		#region Database Path definitions
		[Thinkage.Libraries.Translation.Invariant]
		public class PathClass {
			/// <summary>
			/// Class containing the relationship paths of all tables,
			/// </summary>
			public readonly TAccessor T;
			/// <summary>
			/// Private constructor for singleton creation
			/// </summary>
			private PathClass() {
				T = new TAccessor(this);
			}

			/// <summary>
			/// The instantiation of the singleton Path object
			/// </summary>
			public static readonly PathClass Instance = new PathClass();
			#region DBI_Path Definitions

			#region DBI_Path Permission
			private PathToPermissionRow __pPermission = new PathToPermissionRow( SchemaClass.Instance.T.Permission );

			/// <summary>
			/// The Permission path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToPermissionRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToPrincipalLink _PrincipalID;
				private PathToField _PermissionPathPattern;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToPermissionRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToPermissionRow _BasePath;
					/// <summary>
					/// Provides the path to Permission's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.Permission.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to Permission's PrincipalID with type link(nonnull, field Principal.Id) and labelkey=''
					/// </summary>
					public PathToPrincipalLink PrincipalID { get { if (_BasePath._PrincipalID == null) _BasePath._PrincipalID = new PathToPrincipalLink(_BasePath, Schema.T.Permission.F.PrincipalID ); return _BasePath._PrincipalID; } }
					/// <summary>
					/// Provides the path to Permission's PermissionPathPattern with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) and labelkey='PermissionPathPattern'
					/// </summary>
					public PathToField PermissionPathPattern { get { if (_BasePath._PermissionPathPattern == null) _BasePath._PermissionPathPattern = new PathToField(_BasePath, Schema.T.Permission.F.PermissionPathPattern ); return _BasePath._PermissionPathPattern; } }
				}

				internal PathToPermissionRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToPermissionRow( DBI_Table t ) : base( t ) { }
				internal PathToPermissionRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToPermissionLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToPermissionRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToPermissionRow PathToReferencedRow { get { return (PathToPermissionRow)base.PathToReferencedRow; } }

				internal PathToPermissionLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToPermissionRow(rootTableSchema, columns);
				}
			}
			public class LinkToPermission {
				public LinkToPermission(DBI_Path referencing_path) {
					Id = new PathToPermissionRow(referencing_path.PathThroughLinkage(Schema.T.Permission.F.Id));
				}
				public readonly PathToPermissionRow Id;
			}
			#endregion

			#region DBI_Path Principal
			private PathToPrincipalRow __pPrincipal = new PathToPrincipalRow( SchemaClass.Instance.T.Principal );

			/// <summary>
			/// The Principal path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToPrincipalRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToRoleLink _RoleID;
				private PathToUserLink _UserID;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToPrincipalRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToPrincipalRow _BasePath;
					/// <summary>
					/// Provides the path to Principal's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.Principal.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to Principal's RoleID with type link(field Role.Id) and labelkey='Role'
					/// </summary>
					public PathToRoleLink RoleID { get { if (_BasePath._RoleID == null) _BasePath._RoleID = new PathToRoleLink(_BasePath, Schema.T.Principal.F.RoleID ); return _BasePath._RoleID; } }
					/// <summary>
					/// Provides the path to Principal's UserID with type link(field User.Id) and labelkey='User'
					/// </summary>
					public PathToUserLink UserID { get { if (_BasePath._UserID == null) _BasePath._UserID = new PathToUserLink(_BasePath, Schema.T.Principal.F.UserID ); return _BasePath._UserID; } }
				}

				internal PathToPrincipalRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToPrincipalRow( DBI_Table t ) : base( t ) { }
				internal PathToPrincipalRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToPrincipalLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToPrincipalRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToPrincipalRow PathToReferencedRow { get { return (PathToPrincipalRow)base.PathToReferencedRow; } }

				internal PathToPrincipalLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToPrincipalRow(rootTableSchema, columns);
				}
			}
			public class LinkToPrincipal {
				public LinkToPrincipal(DBI_Path referencing_path) {
					Id = new PathToPrincipalRow(referencing_path.PathThroughLinkage(Schema.T.Principal.F.Id));
				}
				public readonly PathToPrincipalRow Id;
			}
			#endregion

			#region DBI_Path Role
			private PathToRoleRow __pRole = new PathToRoleRow( SchemaClass.Instance.T.Role );

			/// <summary>
			/// The Role path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToRoleRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToPrincipalLink _PrincipalID;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToRoleRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToRoleRow _BasePath;
					/// <summary>
					/// Provides the path to Role's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.Role.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to Role's PrincipalID with type link(nonnull, field Principal.Id) and labelkey=''
					/// </summary>
					public PathToPrincipalLink PrincipalID { get { if (_BasePath._PrincipalID == null) _BasePath._PrincipalID = new PathToPrincipalLink(_BasePath, Schema.T.Role.F.PrincipalID ); return _BasePath._PrincipalID; } }
				}

				internal PathToRoleRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToRoleRow( DBI_Table t ) : base( t ) { }
				internal PathToRoleRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToRoleLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToRoleRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToRoleRow PathToReferencedRow { get { return (PathToRoleRow)base.PathToReferencedRow; } }

				internal PathToRoleLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToRoleRow(rootTableSchema, columns);
				}
			}
			public class LinkToRole {
				public LinkToRole(DBI_Path referencing_path) {
					Id = new PathToRoleRow(referencing_path.PathThroughLinkage(Schema.T.Role.F.Id));
				}
				public readonly PathToRoleRow Id;
			}
			#endregion

			#region DBI_Path User
			private PathToUserRow __pUser = new PathToUserRow( SchemaClass.Instance.T.User );

			/// <summary>
			/// The User path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToPrincipalLink _PrincipalID;
				private PathToField _AuthenticationCredential;
				private PathToField _Hidden;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToUserRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToUserRow _BasePath;
					/// <summary>
					/// Provides the path to User's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.User.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to User's PrincipalID with type link(nonnull, field Principal.Id) and labelkey=''
					/// </summary>
					public PathToPrincipalLink PrincipalID { get { if (_BasePath._PrincipalID == null) _BasePath._PrincipalID = new PathToPrincipalLink(_BasePath, Schema.T.User.F.PrincipalID ); return _BasePath._PrincipalID; } }
					/// <summary>
					/// Provides the path to User's AuthenticationCredential with type string(nonnull, minlength 1, maxlength 128, maxlines 0, trim) and labelkey='Authentication Credential'
					/// </summary>
					public PathToField AuthenticationCredential { get { if (_BasePath._AuthenticationCredential == null) _BasePath._AuthenticationCredential = new PathToField(_BasePath, Schema.T.User.F.AuthenticationCredential ); return _BasePath._AuthenticationCredential; } }
					/// <summary>
					/// Provides the path to User's Hidden with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) and labelkey='Hidden'
					/// </summary>
					public PathToField Hidden { get { if (_BasePath._Hidden == null) _BasePath._Hidden = new PathToField(_BasePath, Schema.T.User.F.Hidden ); return _BasePath._Hidden; } }
				}

				internal PathToUserRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToUserRow( DBI_Table t ) : base( t ) { }
				internal PathToUserRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToUserRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToUserRow PathToReferencedRow { get { return (PathToUserRow)base.PathToReferencedRow; } }

				internal PathToUserLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToUserRow(rootTableSchema, columns);
				}
			}
			public class LinkToUser {
				public LinkToUser(DBI_Path referencing_path) {
					Id = new PathToUserRow(referencing_path.PathThroughLinkage(Schema.T.User.F.Id));
				}
				public readonly PathToUserRow Id;
			}
			#endregion

			#region DBI_Path UserRole
			private PathToUserRoleRow __pUserRole = new PathToUserRoleRow( SchemaClass.Instance.T.UserRole );

			/// <summary>
			/// The UserRole path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserRoleRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToPrincipalLink _PrincipalID;
				private PathToUserLink _UserID;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToUserRoleRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToUserRoleRow _BasePath;
					/// <summary>
					/// Provides the path to UserRole's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.UserRole.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to UserRole's PrincipalID with type link(nonnull, field Principal.Id) and labelkey='Role'
					/// </summary>
					public PathToPrincipalLink PrincipalID { get { if (_BasePath._PrincipalID == null) _BasePath._PrincipalID = new PathToPrincipalLink(_BasePath, Schema.T.UserRole.F.PrincipalID ); return _BasePath._PrincipalID; } }
					/// <summary>
					/// Provides the path to UserRole's UserID with type link(nonnull, field User.Id) and labelkey='User'
					/// </summary>
					public PathToUserLink UserID { get { if (_BasePath._UserID == null) _BasePath._UserID = new PathToUserLink(_BasePath, Schema.T.UserRole.F.UserID ); return _BasePath._UserID; } }
				}

				internal PathToUserRoleRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToUserRoleRow( DBI_Table t ) : base( t ) { }
				internal PathToUserRoleRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserRoleLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToUserRoleRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToUserRoleRow PathToReferencedRow { get { return (PathToUserRoleRow)base.PathToReferencedRow; } }

				internal PathToUserRoleLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToUserRoleRow(rootTableSchema, columns);
				}
			}
			public class LinkToUserRole {
				public LinkToUserRole(DBI_Path referencing_path) {
					Id = new PathToUserRoleRow(referencing_path.PathThroughLinkage(Schema.T.UserRole.F.Id));
				}
				public readonly PathToUserRoleRow Id;
			}
			#endregion

			#region DBI_Path UserPermission
			private PathToUserPermissionRow __pUserPermission = new PathToUserPermissionRow( SchemaClass.Instance.T.UserPermission );

			/// <summary>
			/// The UserPermission path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserPermissionRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToUserLink _UserID;
				private PathToField _PermissionPathPattern;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToUserPermissionRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToUserPermissionRow _BasePath;
					/// <summary>
					/// Provides the path to UserPermission's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.UserPermission.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to UserPermission's UserID with type link(nonnull, field User.Id) and labelkey='User'
					/// </summary>
					public PathToUserLink UserID { get { if (_BasePath._UserID == null) _BasePath._UserID = new PathToUserLink(_BasePath, Schema.T.UserPermission.F.UserID ); return _BasePath._UserID; } }
					/// <summary>
					/// Provides the path to UserPermission's PermissionPathPattern with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) and labelkey='PermissionPathPattern'
					/// </summary>
					public PathToField PermissionPathPattern { get { if (_BasePath._PermissionPathPattern == null) _BasePath._PermissionPathPattern = new PathToField(_BasePath, Schema.T.UserPermission.F.PermissionPathPattern ); return _BasePath._PermissionPathPattern; } }
				}

				internal PathToUserPermissionRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToUserPermissionRow( DBI_Table t ) : base( t ) { }
				internal PathToUserPermissionRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToUserPermissionLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToUserPermissionRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToUserPermissionRow PathToReferencedRow { get { return (PathToUserPermissionRow)base.PathToReferencedRow; } }

				internal PathToUserPermissionLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToUserPermissionRow(rootTableSchema, columns);
				}
			}
			public class LinkToUserPermission {
				public LinkToUserPermission(DBI_Path referencing_path) {
					Id = new PathToUserPermissionRow(referencing_path.PathThroughLinkage(Schema.T.UserPermission.F.Id));
				}
				public readonly PathToUserPermissionRow Id;
			}
			#endregion

			#region DBI_Path License
			private PathToLicenseRow __pLicense = new PathToLicenseRow( SchemaClass.Instance.T.License );

			/// <summary>
			/// The License path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToLicenseRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToField _License;
				private PathToField _ApplicationID;
				private PathToField _Expiry;
				private PathToField _ExpiryModel;
				private PathToField _LicenseCount;
				private PathToField _LicenseModel;
				private PathToField _LicenseID;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToLicenseRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToLicenseRow _BasePath;
					/// <summary>
					/// Provides the path to License's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.License.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to License's License with type string(nonnull, minlength 1, maxlength 29, maxlines 0, trim) and labelkey='License'
					/// </summary>
					public PathToField License { get { if (_BasePath._License == null) _BasePath._License = new PathToField(_BasePath, Schema.T.License.F.License ); return _BasePath._License; } }
					/// <summary>
					/// Provides the path to License's ApplicationID with type integer(nonnull, 32) and labelkey='Application'
					/// </summary>
					public PathToField ApplicationID { get { if (_BasePath._ApplicationID == null) _BasePath._ApplicationID = new PathToField(_BasePath, Schema.T.License.F.ApplicationID ); return _BasePath._ApplicationID; } }
					/// <summary>
					/// Provides the path to License's Expiry with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 00:00), by 24:00) and labelkey='Expiry'
					/// </summary>
					public PathToField Expiry { get { if (_BasePath._Expiry == null) _BasePath._Expiry = new PathToField(_BasePath, Schema.T.License.F.Expiry ); return _BasePath._Expiry; } }
					/// <summary>
					/// Provides the path to License's ExpiryModel with type integer(nonnull, 16) and labelkey='ExpiryModel'
					/// </summary>
					public PathToField ExpiryModel { get { if (_BasePath._ExpiryModel == null) _BasePath._ExpiryModel = new PathToField(_BasePath, Schema.T.License.F.ExpiryModel ); return _BasePath._ExpiryModel; } }
					/// <summary>
					/// Provides the path to License's LicenseCount with type integer(nonnull, 64) and labelkey='LicenseCount'
					/// </summary>
					public PathToField LicenseCount { get { if (_BasePath._LicenseCount == null) _BasePath._LicenseCount = new PathToField(_BasePath, Schema.T.License.F.LicenseCount ); return _BasePath._LicenseCount; } }
					/// <summary>
					/// Provides the path to License's LicenseModel with type integer(nonnull, 16) and labelkey='LicenseModel'
					/// </summary>
					public PathToField LicenseModel { get { if (_BasePath._LicenseModel == null) _BasePath._LicenseModel = new PathToField(_BasePath, Schema.T.License.F.LicenseModel ); return _BasePath._LicenseModel; } }
					/// <summary>
					/// Provides the path to License's LicenseID with type integer(nonnull, 64) and labelkey='License Id'
					/// </summary>
					public PathToField LicenseID { get { if (_BasePath._LicenseID == null) _BasePath._LicenseID = new PathToField(_BasePath, Schema.T.License.F.LicenseID ); return _BasePath._LicenseID; } }
				}

				internal PathToLicenseRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToLicenseRow( DBI_Table t ) : base( t ) { }
				internal PathToLicenseRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToLicenseLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToLicenseRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToLicenseRow PathToReferencedRow { get { return (PathToLicenseRow)base.PathToReferencedRow; } }

				internal PathToLicenseLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToLicenseRow(rootTableSchema, columns);
				}
			}
			public class LinkToLicense {
				public LinkToLicense(DBI_Path referencing_path) {
					Id = new PathToLicenseRow(referencing_path.PathThroughLinkage(Schema.T.License.F.Id));
					License = new PathToLicenseRow(referencing_path.PathThroughLinkage(Schema.T.License.F.License));
				}
				public readonly PathToLicenseRow Id;
				public readonly PathToLicenseRow License;
			}
			#endregion

			#region DBI_Path DatabaseHistory
			private PathToDatabaseHistoryRow __pDatabaseHistory = new PathToDatabaseHistoryRow( SchemaClass.Instance.T.DatabaseHistory );

			/// <summary>
			/// The DatabaseHistory path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToDatabaseHistoryRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToField _EntryDate;
				private PathToField _Subject;
				private PathToField _Description;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToDatabaseHistoryRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToDatabaseHistoryRow _BasePath;
					/// <summary>
					/// Provides the path to DatabaseHistory's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.DatabaseHistory.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to DatabaseHistory's EntryDate with type datetime(nonnull, (min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) and labelkey='EntryDate'
					/// </summary>
					public PathToField EntryDate { get { if (_BasePath._EntryDate == null) _BasePath._EntryDate = new PathToField(_BasePath, Schema.T.DatabaseHistory.F.EntryDate ); return _BasePath._EntryDate; } }
					/// <summary>
					/// Provides the path to DatabaseHistory's Subject with type string(nonnull, minlength 1, maxlength 100, maxlines 0, trim) and labelkey='Subject'
					/// </summary>
					public PathToField Subject { get { if (_BasePath._Subject == null) _BasePath._Subject = new PathToField(_BasePath, Schema.T.DatabaseHistory.F.Subject ); return _BasePath._Subject; } }
					/// <summary>
					/// Provides the path to DatabaseHistory's Description with type string(minlength 1, (maxlength 1,073,741,823), trim) and labelkey='Description'
					/// </summary>
					public PathToField Description { get { if (_BasePath._Description == null) _BasePath._Description = new PathToField(_BasePath, Schema.T.DatabaseHistory.F.Description ); return _BasePath._Description; } }
				}

				internal PathToDatabaseHistoryRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToDatabaseHistoryRow( DBI_Table t ) : base( t ) { }
				internal PathToDatabaseHistoryRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToDatabaseHistoryLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToDatabaseHistoryRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToDatabaseHistoryRow PathToReferencedRow { get { return (PathToDatabaseHistoryRow)base.PathToReferencedRow; } }

				internal PathToDatabaseHistoryLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToDatabaseHistoryRow(rootTableSchema, columns);
				}
			}
			public class LinkToDatabaseHistory {
				public LinkToDatabaseHistory(DBI_Path referencing_path) {
					Id = new PathToDatabaseHistoryRow(referencing_path.PathThroughLinkage(Schema.T.DatabaseHistory.F.Id));
				}
				public readonly PathToDatabaseHistoryRow Id;
			}
			#endregion

			#region DBI_Path BackupFileName
			private PathToBackupFileNameRow __pBackupFileName = new PathToBackupFileNameRow( SchemaClass.Instance.T.BackupFileName );

			/// <summary>
			/// The BackupFileName path information
			/// </summary>
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToBackupFileNameRow : DBI_PathToRow {
				private FAccessor _F;
				public FAccessor F {
					get {
						if (_F == null)
							_F = new FAccessor(this);
						return _F;
					}
				}
				private PathToField _Id;
				private PathToField _LastBackupDate;
				private PathToField _FileName;
				private PathToField _Comment;
				private PathToField _Message;
				private PathToField _DatabaseVersion;
				[Thinkage.Libraries.Translation.Invariant]
				public class FAccessor {
					public FAccessor( PathToBackupFileNameRow basePath ) {
						_BasePath = basePath;
					}
					private readonly PathToBackupFileNameRow _BasePath;
					/// <summary>
					/// Provides the path to BackupFileName's Id with type id(nonnull) and labelkey='Id'
					/// </summary>
					public PathToField Id { get { if (_BasePath._Id == null) _BasePath._Id = new PathToField(_BasePath, Schema.T.BackupFileName.F.Id ); return _BasePath._Id; } }
					/// <summary>
					/// Provides the path to BackupFileName's LastBackupDate with type datetime((min Monday, 01 January 1753 00:00), (max Friday, 31 December 9999 23:59:59.99), divided 100) and labelkey='LastBackupDate'
					/// </summary>
					public PathToField LastBackupDate { get { if (_BasePath._LastBackupDate == null) _BasePath._LastBackupDate = new PathToField(_BasePath, Schema.T.BackupFileName.F.LastBackupDate ); return _BasePath._LastBackupDate; } }
					/// <summary>
					/// Provides the path to BackupFileName's FileName with type string(nonnull, minlength 1, maxlength 256, maxlines 0, trim) and labelkey='FileName'
					/// </summary>
					public PathToField FileName { get { if (_BasePath._FileName == null) _BasePath._FileName = new PathToField(_BasePath, Schema.T.BackupFileName.F.FileName ); return _BasePath._FileName; } }
					/// <summary>
					/// Provides the path to BackupFileName's Comment with type string(minlength 1, (maxlength 1,073,741,823), trim) and labelkey='Comment'
					/// </summary>
					public PathToField Comment { get { if (_BasePath._Comment == null) _BasePath._Comment = new PathToField(_BasePath, Schema.T.BackupFileName.F.Comment ); return _BasePath._Comment; } }
					/// <summary>
					/// Provides the path to BackupFileName's Message with type string(minlength 1, (maxlength 1,073,741,823), trim) and labelkey='Message'
					/// </summary>
					public PathToField Message { get { if (_BasePath._Message == null) _BasePath._Message = new PathToField(_BasePath, Schema.T.BackupFileName.F.Message ); return _BasePath._Message; } }
					/// <summary>
					/// Provides the path to BackupFileName's DatabaseVersion with type string(minlength 1, maxlength 23, maxlines 0) and labelkey='DatabaseVersion'
					/// </summary>
					public PathToField DatabaseVersion { get { if (_BasePath._DatabaseVersion == null) _BasePath._DatabaseVersion = new PathToField(_BasePath, Schema.T.BackupFileName.F.DatabaseVersion ); return _BasePath._DatabaseVersion; } }
				}

				internal PathToBackupFileNameRow( DBI_Table t, DBI_Column[] cols) : base( t, cols ) { }
				internal PathToBackupFileNameRow( DBI_Table t ) : base( t ) { }
				internal PathToBackupFileNameRow( DBI_PathToRow p ) : base( p ) { }
			}
			[Thinkage.Libraries.Translation.Invariant]
			public class PathToBackupFileNameLink : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				public PathToBackupFileNameRow.FAccessor F { get { return PathToReferencedRow.F; } }
				public new PathToBackupFileNameRow PathToReferencedRow { get { return (PathToBackupFileNameRow)base.PathToReferencedRow; } }

				internal PathToBackupFileNameLink( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
				protected override DBI_PathToRow NewPathToRow(DBI_Table rootTableSchema, DBI_Column[] columns) {
					return new PathToBackupFileNameRow(rootTableSchema, columns);
				}
			}
			public class LinkToBackupFileName {
				public LinkToBackupFileName(DBI_Path referencing_path) {
					Id = new PathToBackupFileNameRow(referencing_path.PathThroughLinkage(Schema.T.BackupFileName.F.Id));
					FileName = new PathToBackupFileNameRow(referencing_path.PathThroughLinkage(Schema.T.BackupFileName.F.FileName));
				}
				public readonly PathToBackupFileNameRow Id;
				public readonly PathToBackupFileNameRow FileName;
			}
			#endregion
			public class PathToField : DBI_Path {
				private LAccessor _L;
				public LAccessor L {
					get {
						if (_L == null)
							_L = new LAccessor(this);
						return _L;
					}
				}
				[System.Obsolete("This field is not a linkage field", true)]
				public new PathToField PathToReferencedRow { get { return null; } }

				internal PathToField( DBI_PathToRow rootPath, DBI_Column c ) : base( rootPath, c ) { }
			}
			#endregion
			public struct TAccessor {
				private PathClass this_path;
				public TAccessor( PathClass this_path )
				{
					this.this_path = this_path;
				}
				#region Accessors
				/// <summary>
				/// Provides the root path for Permission with labelkey='Permission'
				/// </summary>
				public PathToPermissionRow Permission { get { return this_path.__pPermission; } }
				/// <summary>
				/// Provides the root path for Principal with labelkey=''
				/// </summary>
				public PathToPrincipalRow Principal { get { return this_path.__pPrincipal; } }
				/// <summary>
				/// Provides the root path for Role with labelkey='Role'
				/// </summary>
				public PathToRoleRow Role { get { return this_path.__pRole; } }
				/// <summary>
				/// Provides the root path for User with labelkey='User'
				/// </summary>
				public PathToUserRow User { get { return this_path.__pUser; } }
				/// <summary>
				/// Provides the root path for UserRole with labelkey=''
				/// </summary>
				public PathToUserRoleRow UserRole { get { return this_path.__pUserRole; } }
				/// <summary>
				/// Provides the root path for UserPermission with labelkey=''
				/// </summary>
				public PathToUserPermissionRow UserPermission { get { return this_path.__pUserPermission; } }
				/// <summary>
				/// Provides the root path for License with labelkey='License'
				/// </summary>
				public PathToLicenseRow License { get { return this_path.__pLicense; } }
				/// <summary>
				/// Provides the root path for DatabaseHistory with labelkey='Database History'
				/// </summary>
				public PathToDatabaseHistoryRow DatabaseHistory { get { return this_path.__pDatabaseHistory; } }
				/// <summary>
				/// Provides the root path for BackupFileName with labelkey='BackupFileName'
				/// </summary>
				public PathToBackupFileNameRow BackupFileName { get { return this_path.__pBackupFileName; } }
				#endregion
			}
			public class LAccessorBase {
				protected LAccessorBase(DBI_Path basePath) {
					BasePath = basePath;
				}
				protected readonly DBI_Path BasePath;
				#region Cached Accessor results
				protected PathClass.LinkToPermission _Permission;
				protected PathClass.LinkToPrincipal _Principal;
				protected PathClass.LinkToRole _Role;
				protected PathClass.LinkToUser _User;
				protected PathClass.LinkToUserRole _UserRole;
				protected PathClass.LinkToUserPermission _UserPermission;
				protected PathClass.LinkToLicense _License;
				protected PathClass.LinkToDatabaseHistory _DatabaseHistory;
				protected PathClass.LinkToBackupFileName _BackupFileName;
				#endregion
			}
			public class LAccessor : LAccessorBase {
				public LAccessor( DBI_Path this_path ) 
					: base(this_path) {
				}
				#region Accessors
				public PathClass.LinkToPermission Permission { get { if (base._Permission == null) base._Permission = new PathClass.LinkToPermission(base.BasePath); return base._Permission; } }
				public PathClass.LinkToPrincipal Principal { get { if (base._Principal == null) base._Principal = new PathClass.LinkToPrincipal(base.BasePath); return base._Principal; } }
				public PathClass.LinkToRole Role { get { if (base._Role == null) base._Role = new PathClass.LinkToRole(base.BasePath); return base._Role; } }
				public PathClass.LinkToUser User { get { if (base._User == null) base._User = new PathClass.LinkToUser(base.BasePath); return base._User; } }
				public PathClass.LinkToUserRole UserRole { get { if (base._UserRole == null) base._UserRole = new PathClass.LinkToUserRole(base.BasePath); return base._UserRole; } }
				public PathClass.LinkToUserPermission UserPermission { get { if (base._UserPermission == null) base._UserPermission = new PathClass.LinkToUserPermission(base.BasePath); return base._UserPermission; } }
				public PathClass.LinkToLicense License { get { if (base._License == null) base._License = new PathClass.LinkToLicense(base.BasePath); return base._License; } }
				public PathClass.LinkToDatabaseHistory DatabaseHistory { get { if (base._DatabaseHistory == null) base._DatabaseHistory = new PathClass.LinkToDatabaseHistory(base.BasePath); return base._DatabaseHistory; } }
				public PathClass.LinkToBackupFileName BackupFileName { get { if (base._BackupFileName == null) base._BackupFileName = new PathClass.LinkToBackupFileName(base.BasePath); return base._BackupFileName; } }
				#endregion
			}
		}
		public static readonly PathClass Path = PathClass.Instance;
		#endregion
		#region Label Key Building
		public class LabelKeyBuilder : Thinkage.Libraries.Translation.GeneralKeyBuilder {
			static LabelKeyBuilder Instance = new LabelKeyBuilder();
			private LabelKeyBuilder() {
			}
			protected override Thinkage.Libraries.Translation.ContextReference GetContext() {
				return Thinkage.Libraries.Translation.ContextReference.New("dsMBLabel");
			}
			public static Thinkage.Libraries.Translation.Key K([Thinkage.Libraries.Translation.Context("dsMBLabel")]string s) {
				return Instance.BuildKey(s);
			}
		}
		#endregion
	}
	#region LabelKeys
	#if DEFINELABELKEYS
	internal static class dsUpgrade_1_1_4_2DefineKeysFordsMBLabel {
		static private Thinkage.Libraries.Translation.Key VariableDBVersion = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("DBVersion");
		static private Thinkage.Libraries.Translation.Key VariableDBServerVersion = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("DBServerVersion");
		static private Thinkage.Libraries.Translation.Key Permission = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Permission");
		static private Thinkage.Libraries.Translation.Key Permission_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key Permission_PrincipalID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("");
		static private Thinkage.Libraries.Translation.Key Permission_PermissionPathPattern = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("PermissionPathPattern");
		static private Thinkage.Libraries.Translation.Key Principal = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("");
		static private Thinkage.Libraries.Translation.Key Principal_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key Principal_RoleID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Role");
		static private Thinkage.Libraries.Translation.Key Principal_UserID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("User");
		static private Thinkage.Libraries.Translation.Key Role = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Role");
		static private Thinkage.Libraries.Translation.Key Role_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key Role_PrincipalID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("");
		static private Thinkage.Libraries.Translation.Key User = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("User");
		static private Thinkage.Libraries.Translation.Key User_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key User_PrincipalID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("");
		static private Thinkage.Libraries.Translation.Key User_AuthenticationCredential = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Authentication Credential");
		static private Thinkage.Libraries.Translation.Key User_Hidden = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Hidden");
		static private Thinkage.Libraries.Translation.Key UserRole = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("");
		static private Thinkage.Libraries.Translation.Key UserRole_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key UserRole_PrincipalID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Role");
		static private Thinkage.Libraries.Translation.Key UserRole_UserID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("User");
		static private Thinkage.Libraries.Translation.Key UserPermission = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("");
		static private Thinkage.Libraries.Translation.Key UserPermission_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key UserPermission_UserID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("User");
		static private Thinkage.Libraries.Translation.Key UserPermission_PermissionPathPattern = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("PermissionPathPattern");
		static private Thinkage.Libraries.Translation.Key License = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("License");
		static private Thinkage.Libraries.Translation.Key License_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key License_License = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("License");
		static private Thinkage.Libraries.Translation.Key License_ApplicationID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Application");
		static private Thinkage.Libraries.Translation.Key License_Expiry = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Expiry");
		static private Thinkage.Libraries.Translation.Key License_ExpiryModel = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("ExpiryModel");
		static private Thinkage.Libraries.Translation.Key License_LicenseCount = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("LicenseCount");
		static private Thinkage.Libraries.Translation.Key License_LicenseModel = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("LicenseModel");
		static private Thinkage.Libraries.Translation.Key License_LicenseID = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("License Id");
		static private Thinkage.Libraries.Translation.Key DatabaseHistory = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Database History");
		static private Thinkage.Libraries.Translation.Key DatabaseHistory_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key DatabaseHistory_EntryDate = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("EntryDate");
		static private Thinkage.Libraries.Translation.Key DatabaseHistory_Subject = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Subject");
		static private Thinkage.Libraries.Translation.Key DatabaseHistory_Description = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Description");
		static private Thinkage.Libraries.Translation.Key BackupFileName = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("BackupFileName");
		static private Thinkage.Libraries.Translation.Key BackupFileName_Id = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Id");
		static private Thinkage.Libraries.Translation.Key BackupFileName_LastBackupDate = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("LastBackupDate");
		static private Thinkage.Libraries.Translation.Key BackupFileName_FileName = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("FileName");
		static private Thinkage.Libraries.Translation.Key BackupFileName_Comment = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Comment");
		static private Thinkage.Libraries.Translation.Key BackupFileName_Message = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("Message");
		static private Thinkage.Libraries.Translation.Key BackupFileName_DatabaseVersion = dsUpgrade_1_1_4_2.LabelKeyBuilder.K("DatabaseVersion");
	}
	#endif
	#endregion
}
