<?xml version="1.0" encoding="utf-8"?>
<database name="http://thinkage.ca/MB3/dsMB.xsd:PurchaseOrderStateHistory" xmlns="http://www.thinkage.ca/XmlNamespaces/XAF">
  <types uri="..\Types.xafdb"/>
  <table name="PurchaseOrderStateHistory" defaults="true" log="false" id="Id" xid="PurchaseOrderID EffectiveDate" labelkey="Purchase Order State History">
    <doc>This record represents a state transition in a Purchase Order</doc>
    <field name="Id" read="RequiredGUID" />
    <field name="Comment" type="Comment"  />
    <field name="EntryDate" type="RequiredDateTime">
      <doc>The date this record was created</doc>
      <extension name="serversetsDateTime"/>
    </field>
    <field name="EffectiveDate" type="RequiredDateTime">
      <doc>The date when the transition takes effect</doc>
      <extension name="servergetsDateTime"/>
    </field>
    <field name="UserID" type="GUIDREF" link="User">
      <doc>Link to the originator of this record; may be null because generation of state may be done by non mainboss user processes</doc>
      <extension name="linkage">captive</extension>
    </field>
    <field name="EffectiveDateReadonly" type="Requiredbool">
      <doc>Control over whether the Effective date should be editable (because it was manually entered) or not</doc>
    </field>
    <field name="PurchaseOrderID" type="RequiredGUIDREF" link="PurchaseOrder">
      <doc>The Purchase Order to which this state transition belongs</doc>
      <extension name="linkage">owner</extension>
    </field>
    <unique>
      <field name="EffectiveDate"/>
      <field name="PurchaseOrderID"/>
    </unique>
    <field labelkey="State" name="PurchaseOrderStateID" type="RequiredGUIDREF" link="PurchaseOrderState">
      <doc>The Purchase Order State to which the transition occurred</doc>
      <extension name="linkage">captive</extension>
		</field>
    <field labelkey="Status" name="PurchaseOrderStateHistoryStatusID" type="GUIDREF" link="PurchaseOrderStateHistoryStatus">
      <doc>The state history status associated with this instance</doc>
      <extension name="linkage">captive</extension>
		</field>
    <!-- We only want to limit the PurchaseOrder that refer to us, not our records themselves so we specify a null lastupdate designation to avoid the default EffectiveDate from being used -->
	<extension name="costrights">PurchaseOrderItem,PurchaseOrderLabor,PurchaseOrderMiscellaneous</extension>
    <extension name="lastupdate"></extension>
  </table>
  <table name="PurchaseOrder"/>
  <table name="PurchaseOrderState"/>
  <table name="PurchaseOrderStateHistoryStatus"/>
  <table name="User"/>
  <table name="ActualItemLocation"/>
  <table name="POLineItem"/>
  <table name="POLine"/>
  <object class="trigger" name="mbtg_PurchaseOrderStateHistory_Updates_PurchaseOrderEtAl">
	<doc></doc>
	<extension name="body">
	  on PurchaseOrderStateHistory
	  after insert
	  as
	  begin
		  -- Theoretically we should do this after updates and before deletes too
		  -- but those operations are not allowed by the app (at least, not in any
		  -- manner that alters the result of the calculation). The "before delete" would
		  -- have to exclude the to-be-deleted records from the subquery and also be
		  -- prepared to find no records, thus setting the field to null. Because some
		  -- of the triggers are before and some after, two triggers would be needed.
		  update PurchaseOrder
			  set CurrentPurchaseOrderStateHistoryID = dbo.mbfn_PurchaseOrder_CurrentPurchaseOrderStateHistory(PurchaseOrder.ID)
			  where PurchaseOrder.ID in (select PurchaseOrderID from inserted)

		  update ActualItemLocation
			 set OnOrder = dbo.mbfn_ActualItemLocation_OnOrder(ActualItemLocation.ID)
			  where ActualItemLocation.ItemLocationID in (
					   select distinct ItemLocationID from POLineItem
							 join POLine on POLineID = POLine.ID
							 join PurchaseOrder on PurchaseOrder.ID = POLine.PurchaseOrderID
							 join inserted on inserted.ID = PurchaseOrder.CurrentPurchaseOrderStateHistoryID
						)
	  end
	</extension>
	<extension name="references">PurchaseOrderStateHistory</extension>
	<extension name="references">PurchaseOrder</extension>
	<extension name="references">ActualItemLocation</extension>
	<extension name="references">POLineItem</extension>
	<extension name="references">POLine</extension>
	<extension name="references">mbfn_PurchaseOrder_currentPurchaseOrderStateHistory()</extension>
	<extension name="references">mbfn_ActualItemLocation_OnOrder()</extension>
  </object>
  <object class="trigger" name="mbtg_EnforcePurchaseOrderStateHistoryOrdering">
	<doc>This enforces the fact that updates to history records cannot alter their existing EffectiveDate ordering for any particular PO</doc>
	<extension name="body">
	  on PurchaseOrderStateHistory
	  for update
	  as
		declare @count int;	<!-- Because we can't use a WITH inside EXISTS(query) we need to query the count into a variable. -->
		<!-- The following query yields the columns from the history table as they were before the update operation -->
		with OriginalHistory as (
			select PurchaseOrderStateHistory.Id, PurchaseOrderStateHistory.PurchaseOrderID, PurchaseOrderStateHistory.EffectiveDate
			  from PurchaseOrderStateHistory
			  left join inserted on PurchaseOrderStateHistory.id = inserted.id
			  where inserted.id is null
		  union
			select Id, PurchaseOrderID, EffectiveDate
			  from deleted
		)
		<!-- Count the number of records for which the update causes the predecessor or successor records (same PO) to change -->
		select @count = count(*)
		  from
			(select
			  Id,
			  (select top 1 Id from PurchaseOrderStateHistory
				where PurchaseOrderID = inserted.PurchaseOrderID and EffectiveDate &gt; inserted.EffectiveDate
				order by EffectiveDate asc),
			  (select top 1 Id from PurchaseOrderStateHistory
				where PurchaseOrderID = inserted.PurchaseOrderID and EffectiveDate &lt; inserted.EffectiveDate
				order by EffectiveDate desc)
			from inserted) as newNeighbours(id, nextid, previd)
		  inner join
			(select
			  Id,
			  (select top 1 Id from OriginalHistory
				where PurchaseOrderID = deleted.PurchaseOrderID and EffectiveDate &gt; deleted.EffectiveDate
				order by EffectiveDate asc),
			  (select top 1 Id from OriginalHistory
				where PurchaseOrderID = deleted.PurchaseOrderID and EffectiveDate &lt; deleted.EffectiveDate
				order by EffectiveDate desc)
			from deleted) as oldNeighbours(id, nextid, previd)
		  on newNeighbours.id = oldneighbours.id
		  where oldNeighbours.nextId != newNeighbours.nextId
			or (oldNeighbours.nextId is null and newNeighbours.nextId is not null)
			or (oldNeighbours.nextId is not null and newNeighbours.nextId is null)
			or oldNeighbours.previd != newNeighbours.previd
			or (oldNeighbours.previd is null and newNeighbours.previd is not null)
			or (oldNeighbours.previd is not null and newNeighbours.previd is null)
		if @count &gt; 0 begin
		  raiserror('EffectiveDate-order of records in table ''%s'' cannot be altered', 16, 1, 'PurchaseOrderStateHistory')
		  rollback transaction
		end
	</extension>
	<extension name="references">PurchaseOrderStateHistory</extension>
  </object>
  <object class="trigger" name="mbtg_EnforceNewPurchaseOrderStateHistoryOrdering">
	<doc>This enforces the rule that new state history records cannot predate (in EffectiveDate order) existing ones for the same PO</doc>
	<extension name="body">
	  on PurchaseOrderStateHistory
	  for insert
	  as
		declare @count int;	<!-- Because we can't use a WITH inside EXISTS(query) we need to query the count into a variable. -->
		<!-- The following query yields the columns from the history table as they were before the insert operation -->
		with OriginalHistory as (
		  select PurchaseOrderStateHistory.Id, PurchaseOrderStateHistory.PurchaseOrderID, PurchaseOrderStateHistory.EffectiveDate
			from PurchaseOrderStateHistory
			left join inserted on PurchaseOrderStateHistory.id = inserted.id
			where inserted.id is null
		)
		<!-- Count the number of History records that post-date any newly inserted ones on the same work orders -->
		select @count = count(*)
		  from OriginalHistory
		  inner join inserted on OriginalHistory.PurchaseOrderID = inserted.PurchaseOrderID
		  where OriginalHistory.EffectiveDate &gt; inserted.EffectiveDate
		if @count &gt; 0 begin
		  raiserror('EffectiveDate-order of new records in table ''%s'' must be later than those of existing records for the same %s', 16, 1, 'PurchaseOrderStateHistory', 'Purchase Order')
		  rollback transaction
		end
	</extension>
	<extension name="references">PurchaseOrderStateHistory</extension>
  </object>
</database>
