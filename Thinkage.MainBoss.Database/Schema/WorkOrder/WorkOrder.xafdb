<?xml version="1.0" encoding="utf-8"?>
<database xmlns="http://www.thinkage.ca/XmlNamespaces/XAF">
  <types uri="..\Types.xafdb"/>

  <variable name="WOSequence" type="integer(unsigned 63,nonnull)">
	<doc>The integer to be used in conjunction with WOSequenceFormat to produce the new Work Order Number</doc>
  </variable>
  <variable name="WOSequenceFormat" type="RequiredAutoNumber">
	<doc>The format specification for producing the new Work Order Number</doc>
  </variable>
  <variable name="WODefaultDuration" type="WorkOrderDuration">
	<doc>The duration default for new manually-entered workorders. PM-generated Work Orders are not affected by this, where the Duration comes from the Task(s).</doc>
  </variable>
  <variable name="WODefaultSlackDays" type="WorkOrderDuration">
	<doc>The default for Slack Days for new manually-entered workorders. PM-generated Work Orders are not affected by this, where the Slack Days come from the Maintenance Plan (SWO).</doc>
  </variable>

  <table name="WorkOrder" defaults="true" log="false" id="Id" xid="Number" xunique="true" labelkey="Work Order">
	<field name="Id" read="RequiredGUID" />
	<field name="Number" type="RequiredAutoNumber">
	  <doc>The Work Order Number, as generated by WOSequence and WOSequenceFormat, or as entered by the user</doc>
	</field>
	<field name="UnitLocationID" labelkey="Unit" type="RequiredGUIDREF"  link="Location">
	  <doc>The unit on which the work is to be performed</doc>
	  <extension name="pickfrom">Thinkage.MainBoss.Controls.TILocations.UnitBrowseTblCreator,Thinkage.MainBoss.Controls</extension>
	  <extension name="linkage">property</extension>
	</field>
	<field name="CurrentWorkOrderStateHistoryID" read="RequiredGUIDREF"  link="WorkOrderStateHistory" labelkey="Current State History">
	  <doc>Calculated link to the current WorkOrderStateHistory record</doc>
	  <result hosting="cached">
		cast(workorder.id as link(WorkOrderStateHistory, nonnull))
	  </result>
	  <extension name="dependson">WorkOrderStateHistory@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.WorkOrderID@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.EffectiveDate@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	</field>
	<field name="FirstWorkOrderStateHistoryID" read="RequiredGUIDREF"  link="WorkOrderStateHistory" labelkey="First State History">
	  <doc>Calculated link to the first WorkOrderStateHistory record</doc>
	  <result hosting="cached">
		cast(workorder.id as link(WorkOrderStateHistory, nonnull))
	  </result>
	  <extension name="dependson">WorkOrderStateHistory@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.WorkOrderID@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	</field>
	<field name="FirstOpenWorkOrderStateHistoryID" read="GUIDREF"  link="WorkOrderStateHistory" labelkey="First State History">
	  <doc>Calculated link to the first WorkOrderStateHistory record in the Open state</doc>
	  <result hosting="cached">
		cast(null as link(WorkOrderStateHistory, null))
	  </result>
	  <extension name="dependson">WorkOrderStateHistory@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.WorkOrderID@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	</field>
	<field name="CompletionWorkOrderStateHistoryID" read="GUIDREF"  link="WorkOrderStateHistory" labelkey="Work Completion State History">
	  <doc>Calculated link to the WorkOrderStateHistory record that marks the completion of the work</doc>
	  <result hosting="cached">
		cast(null as link(WorkOrderStateHistory, null))
	  </result>
	  <extension name="dependson">WorkOrderStateHistory@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.WorkOrderID@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	</field>
	<field name="Subject" type="RequiredSubject">
	  <doc>A 1-line description of the work to be done</doc>
	</field>
	<field name="Description" type="MultiLineUnlimited">
	  <doc>A detailed description of the work to be done, along with notes entered as work proceeds</doc>
	</field>
	<field name="ClosingComment" type="Comment" labelkey="Comment">
	  <doc>A comment specifically dealing with how and why the work was considered complete</doc>
	  <extension name="lines">2</extension>
	</field>
	<field name="RequestorID" type="GUIDREF"  link="Requestor">
	  <doc>The person who requested that the work be done</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="WorkCategoryID" type="GUIDREF"  link="WorkCategory">
	  <doc>the category assigned the work order</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="WorkOrderExpenseModelID" type="RequiredGUIDREF"  link="WorkOrderExpenseModel" labelkey="Expense Model">
	  <doc>The work order expense model to be used for determining how resource costs are to be charged</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="AccessCodeID" type="GUIDREF"  link="AccessCode">
	  <doc>A code representing how and when the unit might be accessed for service</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="ProjectID" type="GUIDREF"  link="Project">
	  <doc>A code to classify the work order under a particular project</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="WorkOrderPriorityID" type="GUIDREF"  link="WorkOrderPriority" labelkey="Priority">
	  <doc>A code determining what priority this work order has</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="CloseCodeID" type="GUIDREF"  link="CloseCode">
	  <doc>A code summarizing how and why the work was considered complete</doc>
	  <extension name="linkage">property</extension>
	</field>
	<field name="Downtime" type="Downtime">
	  <doc>
		The amount of time the Unit was down.
		We do not specify whether this is continuous calendar time or lost work time, nor whether or not this includes
		the downtime caused by a failure prior to the start of the work in this work order.
	  </doc>
	</field>
	<field name="StartDateEstimate" type="RequiredDate" labelkey="Planned Start Date">
	  <doc>
		an estimate (and eventually a firm value) for when the work actually starts. Ultimately all resource actuals
		must occur on or after this date.
	  </doc>
	  <extension name="servergetsDateTime"/>
	</field>
	<field name="EndDateEstimate" type="RequiredDate" labelkey="Planned End Date">
	  <doc>
		an estimate (and eventually a firm value) for the last day work is done. Ultimately all resource actuals must occur
		on or before this date.
	  </doc>
	</field>
	<field name="WorkDueDate" type="Date" labelkey="Work Due Date">
	  <doc>
		A date at which point, if the work order is not closed, the work is considered overdue.
		The work order can be considered overdue before this date if the remaining work interval
		goes beyond the due date.
	  </doc>
	</field>
	<field name="PreviousWorkedDays" read="RequiredDaySpan">
	  <doc>This is the count of days since the StartDateEstimate that the Work Order has been Open, not including open time for
	  the Current State History record. In particular, if the current state history is Open, this count does NOT include
	  the day of the effective date of the current state history record.</doc>
	  <result hosting="cached">
		cast(42 as RequiredDaySpan)
	  </result>
	  <extension name="dependson">WorkOrderStateHistory@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.WorkOrderID@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrderStateHistory.EffectiveDate@WorkOrderStateHistory.WorkOrderID->WorkOrder.ID</extension>
	  <extension name="dependson">WorkOrder.StartDateEstimate@WorkOrder</extension>
	</field>
	<field name="SelectPrintFlag" type="Requiredbool" labelkey="Select for Printing">
	  <doc>Interim flag for support of a SelectForPrint operation; will migrate to general flags model in future</doc>
	</field>
	<field name="TotalDemand" read="RequiredCurrency">
	  <doc>
		The total of all Demands made against this WorkOrder, maintained by a trigger in the Demand Table
	  </doc>
	  <result hosting="cached">
		cast(42 as RequiredCurrency)
	  </result>
	  <extension name="dependson">mbfn_WorkOrder_TotalDemand()</extension>
	</field>
	<field name="TotalActual" read="RequiredCurrency">
	  <doc>
		The total of all Demands made against this WorkOrder, maintained by a trigger in the Demand Table
	  </doc>
	  <result hosting="cached">
		cast(42 as RequiredCurrency)
	  </result>
	  <extension name="dependson">mbfn_WorkOrder_TotalActual()</extension>
	</field>
	<field name="TemporaryStorageEmpty" read="RequiredBool">
	  <doc>
		A flag indicating that all the temporary storage is empty, i.e. the quantities and values for each TemporaryItemLocation on this WO
		each total to zero individually.
	  </doc>
	  <result hosting="cached">
		cast(true as RequiredBool)
	  </result>
	  <extension name="dependson">mbfn_WorkOrder_TemporaryStorageEmpty()</extension>
	</field>
	<extension name="costrights">UnitValue</extension>
	<extension name="lastupdate">CurrentWorkOrderStateHistoryID.EffectiveDate</extension>
	<extension name="equate">CurrentWorkOrderStateHistoryID.WorkOrderID=Id</extension>
  </table>
  <object class="function" name="mbfn_WorkOrder_PreviousWorkedDays">
	<doc>
	  Calculates PreviousWorkedDays from scratch for cases when the StartDateEstimate or state history EffectiveDates change.
	  New state history records maintain that field incrementally.
	</doc>
	<extension name="body">
	  (
	  @ID		uniqueidentifier	-- WorkOrderID
	  )
	  RETURNS XAFInterval
	  as
	  begin
		declare @Result integer;
		<!-- Join the State History to its following record and return all the inclusive dates that each WO was open at least
			  during part of the day, ignoring any dates before the work start date.
			  Note that we also return a row for the current state history if it is Open, in which case E has no position and we return a
			  crossed end-date so it counts as zero days.
			  These date ranges are all ones in which we assume work has occurred. -->
		with WorkIntervalsSoFar(FirstIntervalDate, LastIntervalDate, seq) as (
			select
				case when cast(S.EffectiveDate as Date) > wo.StartDateEstimate then cast(S.EffectiveDate as Date) else cast(wo.StartDateEstimate as date) end,
				case when E.EffectiveDate is null
				  then dateadd(day, -1, case when cast(S.EffectiveDate as Date) > wo.StartDateEstimate then cast(S.EffectiveDate as Date) else cast(wo.StartDateEstimate as date) end)
				  else cast(E.EffectiveDate as Date) end,
				row_number() over (order by S.EffectiveDate asc)
			from WorkOrderStateHistory as S
			join WorkOrder as wo on wo.Id = S.WorkOrderID
			join WorkOrderState as SS on SS.Id = S.WorkOrderStateID
			left join WorkOrderStateHistory as E on E.PreviousWorkOrderStateHistoryID = s.Id
			where ss.FilterAsOpen != 0
				and (cast(E.EffectiveDate as Date) >= wo.StartDateEstimate)
				and S.WorkOrderID = @ID
		)
		<!-- This calculates the number of days open for each record from WorkIntervalsSoFar. Each open interval counts as end - start + 1 because
			  the count is inclusive, but if the next record for the same WO starts on the day this one ended, one less is counted
			  so the shared day does not get double-counted. This includes the special record for the current WOSH if it is open.
			  We can't use exists to check if the next record has the same start as our end because MS Sql does not allow subqueries
			  within aggregate functions. Instead we use a left join to look ahead. Unfortunately we need a sequence number to reliably find the next record.
			  anything else e.g. looking for an effective date higher than our ending effective date, will not work. -->
		select @result = sum(case when iNext.seq is not null
				then datediff(day, I.FirstIntervalDate, I.LastIntervalDate)			<!-- The next work interval starts on our end date -->
				else datediff(day, I.FirstIntervalDate, I.LastIntervalDate) + 1 end)	<!-- The next work interval if any starts at least a day later -->
			from
				WorkIntervalsSoFar as I
				left join WorkIntervalsSoFar as INext
					on I.seq = inext.seq - 1
						and I.LastIntervalDate = inext.FirstIntervalDate
		return coalesce(dbo._INew(@result, 0, 0, 0, 0), 0)
	  end
	</extension>
	<extension name="dependson">WorkOrderStateHistory</extension>
  </object>
  <object class="function" name="mbfn_WorkOrder_TotalDemand">
	<doc>
	  Total all the Cost Estimate values for this workorder over all Demands.
	</doc>
	<extension name="body">
	  (
	  @WID		uniqueidentifier	-- WorkOrderID
	  )
	  RETURNS money
	  as
	  begin
	  return (
	  select coalesce(SUM(Demand.CostEstimate), 0)
	  from Demand
	  where Demand.WorkOrderID = @WID
	  )
	  end
	</extension>
	<extension name="dependson">Demand</extension>
  </object>
  <object class="function" name="mbfn_WorkOrder_TotalActual">
	<doc>
	  Total all the Actual values for this workorder over all Demands.
	</doc>
	<extension name="body">
	  (
	  @WID		uniqueidentifier	-- WorkOrderID
	  )
	  RETURNS money
	  as
	  begin
	  return (
	  select coalesce(SUM(Demand.ActualCost), 0)
	  from Demand
	  where Demand.WorkOrderID = @WID
	  )
	  end
	</extension>
	<extension name="dependson">Demand</extension>
  </object>
  <object class="function" name="mbfn_WorkOrder_TemporaryStorageEmpty">
	<doc>
	  Determine if all temporary storage is empty for this WO
	</doc>
	<extension name="body">
	  (
	  @WID		uniqueidentifier	-- WorkOrderID
	  )
	  RETURNS int
	  as
	  begin
	  return (
	  case when exists (
	  select *
	  from ActualItemLocation as AIL
	  join ItemLocation as IL on IL.ID = AIL.ItemLocationID
	  join TemporaryStorage as TS on TS.LocationID = IL.LocationID
	  where TS.WorkOrderID = @WID
	  and (AIL.TotalCost != 0 or AIL.OnHand != 0)
	  ) then 0 else 1 end
	  )
	  end
	</extension>
	<extension name="dependson">ActualItemLocation.TotalCost</extension>
	<extension name="dependson">ActualItemLocation.OnHand</extension>
  </object>
  <object class="trigger" name="mbtg_SetUpdatedWorkOrderCodes">
	<doc>This trigger updates the codes for all associated TemporaryStorage records</doc>
	<extension name="body">
	  on WorkOrder
	  for update
	  as
	  if update(Number) begin
	  -- Update the compound codes of all the altered records and everything contained in them.
	  update Location set Code = inserted.Number + ' @ ' + CGL.Code
	  from Location
	  join TemporaryStorage as TS on TS.LocationID = Location.ID
	  join inserted on inserted.ID = TS.WorkOrderID
	  join deleted on inserted.ID = deleted.ID
	  join Location as CGL on TS.ContainingLocationID = CGL.ID
	  where convert(varbinary(max), inserted.Number) != convert(varbinary(max), deleted.Number)
	  end
	</extension>
	<extension name="references">Location</extension>
	<extension name="references">TemporaryStorage</extension>
	<extension name="references">WorkOrder</extension>
  </object>
  <object class="trigger" name="mbtg_WorkOrder_PreviousWorkedDays">
	<extension name="body">
	  on WorkOrder
	  for update
	  as
		if update(StartDateEstimate) begin
		  update WorkOrder
			set PreviousWorkedDays = dbo.mbfn_WorkOrder_PreviousWorkedDays(Id)
			where Id in (select inserted.Id from inserted join deleted on inserted.Id = deleted.Id where inserted.StartDateEstimate != deleted.StartDateEstimate)
		end
	</extension>
	<extension name="references">WorkOrder</extension>
	<extension name="references">WorkOrder</extension>
  </object>
  <table name="Location"/>
  <table name="WorkOrderStateHistory">
	<field name="WorkOrderID"/>
	<field name="EffectiveDate"/>
  </table>
  <table name="Requestor"/>
  <table name="WorkCategory"/>
  <table name="WorkOrderExpenseModel"/>
  <table name="AccessCode"/>
  <table name="Project"/>
  <table name="WorkOrderPriority"/>
  <table name="CloseCode"/>
  <table name="PMGenerationBatch"/>
  <table name="ActualItemLocation">
	<field name="TotalCost"/>
	<field name="OnHand"/>
  </table>
  <table name="ItemLocation"/>
  <table name="TemporaryStorage"/>
  <table name="Demand"/>
</database>
